// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package uniffi.vodozemac

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.IntegerType
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.Callback
import com.sun.jna.ptr.*
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

/**
 * @suppress
 */
@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    // Note: `capacity` and `len` are actually `ULong` values, but JVM only supports signed values.
    // When dealing with these fields, make sure to call `toULong()`.
    @JvmField var capacity: Long = 0
    @JvmField var len: Long = 0
    @JvmField var data: Pointer? = null

    class ByValue: RustBuffer(), Structure.ByValue
    class ByReference: RustBuffer(), Structure.ByReference

   internal fun setValue(other: RustBuffer) {
        capacity = other.capacity
        len = other.len
        data = other.data
    }

    companion object {
        internal fun alloc(size: ULong = 0UL) = uniffiRustCall() { status ->
            // Note: need to convert the size to a `Long` value to make this work with JVM.
            UniffiLib.INSTANCE.ffi_vodozemac_bindings_rustbuffer_alloc(size.toLong(), status)
        }.also {
            if(it.data == null) {
               throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
           }
        }

        internal fun create(capacity: ULong, len: ULong, data: Pointer?): RustBuffer.ByValue {
            var buf = RustBuffer.ByValue()
            buf.capacity = capacity.toLong()
            buf.len = len.toLong()
            buf.data = data
            return buf
        }

        internal fun free(buf: RustBuffer.ByValue) = uniffiRustCall() { status ->
            UniffiLib.INSTANCE.ffi_vodozemac_bindings_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 *
 * @suppress
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setLong(0, value.capacity)
        pointer.setLong(8, value.len)
        pointer.setPointer(16, value.data)
    }

    /**
     * Get a `RustBuffer.ByValue` from this reference.
     */
    fun getValue(): RustBuffer.ByValue {
        val pointer = getPointer()
        val value = RustBuffer.ByValue()
        value.writeField("capacity", pointer.getLong(0))
        value.writeField("len", pointer.getLong(8))
        value.writeField("data", pointer.getLong(16))

        return value
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
internal open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
/**
 * The FfiConverter interface handles converter types to and from the FFI
 *
 * All implementing objects should be public to support external types.  When a
 * type is external we need to import it's FfiConverter.
 *
 * @suppress
 */
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): ULong

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position().toLong())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

/**
 * FfiConverter that uses `RustBuffer` as the FfiType
 *
 * @suppress
 */
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.

internal const val UNIFFI_CALL_SUCCESS = 0.toByte()
internal const val UNIFFI_CALL_ERROR = 1.toByte()
internal const val UNIFFI_CALL_UNEXPECTED_ERROR = 2.toByte()

@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
    @JvmField var code: Byte = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue: UniffiRustCallStatus(), Structure.ByValue

    fun isSuccess(): Boolean {
        return code == UNIFFI_CALL_SUCCESS
    }

    fun isError(): Boolean {
        return code == UNIFFI_CALL_ERROR
    }

    fun isPanic(): Boolean {
        return code == UNIFFI_CALL_UNEXPECTED_ERROR
    }

    companion object {
        fun create(code: Byte, errorBuf: RustBuffer.ByValue): UniffiRustCallStatus.ByValue {
            val callStatus = UniffiRustCallStatus.ByValue()
            callStatus.code = code
            callStatus.error_buf = errorBuf
            return callStatus
        }
    }
}

class InternalException(message: String) : kotlin.Exception(message)

/**
 * Each top-level error class has a companion object that can lift the error from the call status's rust buffer
 *
 * @suppress
 */
interface UniffiRustCallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: kotlin.Exception> uniffiRustCallWithError(errorHandler: UniffiRustCallStatusErrorHandler<E>, callback: (UniffiRustCallStatus) -> U): U {
    var status = UniffiRustCallStatus()
    val return_value = callback(status)
    uniffiCheckCallStatus(errorHandler, status)
    return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun<E: kotlin.Exception> uniffiCheckCallStatus(errorHandler: UniffiRustCallStatusErrorHandler<E>, status: UniffiRustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

/**
 * UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
 *
 * @suppress
 */
object UniffiNullRustCallStatusErrorHandler: UniffiRustCallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U {
    return uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback)
}

internal inline fun<T> uniffiTraitInterfaceCall(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
        callStatus.error_buf = FfiConverterString.lower(e.toString())
    }
}

internal inline fun<T, reified E: Throwable> uniffiTraitInterfaceCallWithError(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
    lowerError: (E) -> RustBuffer.ByValue
) {
    try {
        writeReturn(makeCall())
    } catch(e: kotlin.Exception) {
        if (e is E) {
            callStatus.code = UNIFFI_CALL_ERROR
            callStatus.error_buf = lowerError(e)
        } else {
            callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
            callStatus.error_buf = FfiConverterString.lower(e.toString())
        }
    }
}
// Initial value and increment amount for handles. 
// These ensure that Kotlin-generated handles always have the lowest bit set
private const val UNIFFI_HANDLEMAP_INITIAL = 1.toLong()
private const val UNIFFI_HANDLEMAP_DELTA = 2.toLong()

// Map handles to objects
//
// This is used pass an opaque 64-bit handle representing a foreign object to the Rust code.
internal class UniffiHandleMap<T: Any> {
    private val map = ConcurrentHashMap<Long, T>()
    // Start 
    private val counter = java.util.concurrent.atomic.AtomicLong(UNIFFI_HANDLEMAP_INITIAL)

    val size: Int
        get() = map.size

    // Insert a new object into the handle map and get a handle for it
    fun insert(obj: T): Long {
        val handle = counter.getAndAdd(UNIFFI_HANDLEMAP_DELTA)
        map.put(handle, obj)
        return handle
    }

    // Clone a handle, creating a new one
    fun clone(handle: Long): Long {
        val obj = map.get(handle) ?: throw InternalException("UniffiHandleMap.clone: Invalid handle")
        return insert(obj)
    }

    // Get an object from the handle map
    fun get(handle: Long): T {
        return map.get(handle) ?: throw InternalException("UniffiHandleMap.get: Invalid handle")
    }

    // Remove an entry from the handlemap and get the Kotlin object back
    fun remove(handle: Long): T {
        return map.remove(handle) ?: throw InternalException("UniffiHandleMap: Invalid handle")
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "vodozemac_bindings"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// Define FFI callback types
internal interface UniffiRustFutureContinuationCallback : com.sun.jna.Callback {
    fun callback(`data`: Long,`pollResult`: Byte,)
}
internal interface UniffiForeignFutureDroppedCallback : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
internal interface UniffiCallbackInterfaceFree : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
}
internal interface UniffiCallbackInterfaceClone : com.sun.jna.Callback {
    fun callback(`handle`: Long,)
    : Long
}
@Structure.FieldOrder("handle", "free")
internal open class UniffiForeignFutureDroppedCallbackStruct(
    @JvmField internal var `handle`: Long = 0.toLong(),
    @JvmField internal var `free`: UniffiForeignFutureDroppedCallback? = null,
) : Structure() {
    class UniffiByValue(
        `handle`: Long = 0.toLong(),
        `free`: UniffiForeignFutureDroppedCallback? = null,
    ): UniffiForeignFutureDroppedCallbackStruct(`handle`,`free`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureDroppedCallbackStruct) {
        `handle` = other.`handle`
        `free` = other.`free`
    }

}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI8(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI8 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI8.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI16(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI16 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI16.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultU64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultU64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultU64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteU64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultU64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultI64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultI64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultI64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteI64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultI64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultF32(
    @JvmField internal var `returnValue`: Float = 0.0f,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Float = 0.0f,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultF32(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultF32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF32 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultF32.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultF64(
    @JvmField internal var `returnValue`: Double = 0.0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Double = 0.0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultF64(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultF64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteF64 : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultF64.UniffiByValue,)
}
@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureResultRustBuffer(
    @JvmField internal var `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultRustBuffer(`returnValue`,`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultRustBuffer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteRustBuffer : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultRustBuffer.UniffiByValue,)
}
@Structure.FieldOrder("callStatus")
internal open class UniffiForeignFutureResultVoid(
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ): UniffiForeignFutureResultVoid(`callStatus`,), Structure.ByValue

   internal fun uniffiSetValue(other: UniffiForeignFutureResultVoid) {
        `callStatus` = other.`callStatus`
    }

}
internal interface UniffiForeignFutureCompleteVoid : com.sun.jna.Callback {
    fun callback(`callbackData`: Long,`result`: UniffiForeignFutureResultVoid.UniffiByValue,)
}


















































































































































































































































































































































































































































































































































// For large crates we prevent `MethodTooLargeException` (see #2340)
// N.B. the name of the extension is very misleading, since it is 
// rather `InterfaceTooLargeException`, caused by too many methods 
// in the interface for large crates.
//
// By splitting the otherwise huge interface into two parts
// * UniffiLib 
// * IntegrityCheckingUniffiLib (this)
// we allow for ~2x as many methods in the UniffiLib interface.
// 
// The `ffi_uniffi_contract_version` method and all checksum methods are put 
// into `IntegrityCheckingUniffiLib` and these methods are called only once,
// when the library is loaded.
internal interface IntegrityCheckingUniffiLib : Library {
    // Integrity check functions only
    fun uniffi_vodozemac_bindings_checksum_func_base64_decode(
): Short
fun uniffi_vodozemac_bindings_checksum_func_base64_encode(
): Short
fun uniffi_vodozemac_bindings_checksum_func_get_version(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_create_inbound_session(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_create_outbound_session(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_curve25519_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_ed25519_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_forget_fallback_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_generate_fallback_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_generate_one_time_keys(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_identity_keys(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_mark_keys_as_published(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_max_number_of_one_time_keys(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_one_time_keys(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_pickle(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_sign(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_stored_one_time_key_count(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_to_dehydrated_device(
): Short
fun uniffi_vodozemac_bindings_checksum_method_account_to_libolm_pickle(
): Short
fun uniffi_vodozemac_bindings_checksum_method_accountpickle_encrypt(
): Short
fun uniffi_vodozemac_bindings_checksum_method_checkcode_as_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_checkcode_to_digit(
): Short
fun uniffi_vodozemac_bindings_checksum_method_curve25519publickey_as_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_curve25519publickey_length(
): Short
fun uniffi_vodozemac_bindings_checksum_method_curve25519publickey_to_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_method_curve25519publickey_to_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_curve25519publickey_to_vec(
): Short
fun uniffi_vodozemac_bindings_checksum_method_curve25519secretkey_diffie_hellman(
): Short
fun uniffi_vodozemac_bindings_checksum_method_curve25519secretkey_public_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_curve25519secretkey_to_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_decryptedmessage_message_index(
): Short
fun uniffi_vodozemac_bindings_checksum_method_decryptedmessage_plaintext(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ecies_establish_inbound_channel(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ecies_establish_outbound_channel(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ecies_public_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ed25519keypair_public_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ed25519keypair_sign(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ed25519publickey_as_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ed25519publickey_length(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ed25519publickey_to_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ed25519publickey_verify(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ed25519secretkey_length(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ed25519secretkey_public_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ed25519secretkey_sign(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ed25519secretkey_to_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ed25519secretkey_to_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ed25519signature_length(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ed25519signature_to_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ed25519signature_to_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_establishedecies_check_code(
): Short
fun uniffi_vodozemac_bindings_checksum_method_establishedecies_decrypt(
): Short
fun uniffi_vodozemac_bindings_checksum_method_establishedecies_encrypt(
): Short
fun uniffi_vodozemac_bindings_checksum_method_establishedecies_public_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_establishedsas_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_establishedsas_bytes_raw(
): Short
fun uniffi_vodozemac_bindings_checksum_method_establishedsas_calculate_mac(
): Short
fun uniffi_vodozemac_bindings_checksum_method_establishedsas_calculate_mac_invalid_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_method_establishedsas_our_public_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_establishedsas_their_public_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_establishedsas_verify_mac(
): Short
fun uniffi_vodozemac_bindings_checksum_method_exportedsessionkey_to_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_method_exportedsessionkey_to_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_groupsession_encrypt(
): Short
fun uniffi_vodozemac_bindings_checksum_method_groupsession_message_index(
): Short
fun uniffi_vodozemac_bindings_checksum_method_groupsession_pickle(
): Short
fun uniffi_vodozemac_bindings_checksum_method_groupsession_session_id(
): Short
fun uniffi_vodozemac_bindings_checksum_method_groupsession_session_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_groupsessionpickle_encrypt(
): Short
fun uniffi_vodozemac_bindings_checksum_method_identitykeys_curve25519(
): Short
fun uniffi_vodozemac_bindings_checksum_method_identitykeys_ed25519(
): Short
fun uniffi_vodozemac_bindings_checksum_method_inboundcreationresult_ecies(
): Short
fun uniffi_vodozemac_bindings_checksum_method_inboundcreationresult_message(
): Short
fun uniffi_vodozemac_bindings_checksum_method_inboundgroupsession_compare(
): Short
fun uniffi_vodozemac_bindings_checksum_method_inboundgroupsession_decrypt(
): Short
fun uniffi_vodozemac_bindings_checksum_method_inboundgroupsession_export_at(
): Short
fun uniffi_vodozemac_bindings_checksum_method_inboundgroupsession_first_known_index(
): Short
fun uniffi_vodozemac_bindings_checksum_method_inboundgroupsession_pickle(
): Short
fun uniffi_vodozemac_bindings_checksum_method_inboundgroupsession_session_id(
): Short
fun uniffi_vodozemac_bindings_checksum_method_inboundgroupsessionpickle_encrypt(
): Short
fun uniffi_vodozemac_bindings_checksum_method_initialmessage_ciphertext(
): Short
fun uniffi_vodozemac_bindings_checksum_method_initialmessage_encode(
): Short
fun uniffi_vodozemac_bindings_checksum_method_initialmessage_public_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_invalidcount_message(
): Short
fun uniffi_vodozemac_bindings_checksum_method_keyid_to_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_method_mac_as_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_mac_to_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_method_megolmmessage_ciphertext(
): Short
fun uniffi_vodozemac_bindings_checksum_method_megolmmessage_message_index(
): Short
fun uniffi_vodozemac_bindings_checksum_method_megolmmessage_to_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_method_megolmmessage_to_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_message_ciphertext(
): Short
fun uniffi_vodozemac_bindings_checksum_method_message_encode(
): Short
fun uniffi_vodozemac_bindings_checksum_method_olminboundcreationresult_plaintext(
): Short
fun uniffi_vodozemac_bindings_checksum_method_olminboundcreationresult_session(
): Short
fun uniffi_vodozemac_bindings_checksum_method_olmmessage_message_type(
): Short
fun uniffi_vodozemac_bindings_checksum_method_olmmessage_to_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_method_olmnormalmessage_chain_index(
): Short
fun uniffi_vodozemac_bindings_checksum_method_olmnormalmessage_ciphertext(
): Short
fun uniffi_vodozemac_bindings_checksum_method_olmnormalmessage_mac_truncated(
): Short
fun uniffi_vodozemac_bindings_checksum_method_olmnormalmessage_ratchet_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_olmnormalmessage_to_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_method_olmnormalmessage_to_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_olmnormalmessage_version(
): Short
fun uniffi_vodozemac_bindings_checksum_method_onetimekeygenerationresult_discarded(
): Short
fun uniffi_vodozemac_bindings_checksum_method_onetimekeygenerationresult_generated(
): Short
fun uniffi_vodozemac_bindings_checksum_method_onetimekeypair_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_onetimekeypair_key_id(
): Short
fun uniffi_vodozemac_bindings_checksum_method_outboundcreationresult_ecies(
): Short
fun uniffi_vodozemac_bindings_checksum_method_outboundcreationresult_message(
): Short
fun uniffi_vodozemac_bindings_checksum_method_prekeymessage_base_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_prekeymessage_identity_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_prekeymessage_message(
): Short
fun uniffi_vodozemac_bindings_checksum_method_prekeymessage_one_time_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_prekeymessage_session_id(
): Short
fun uniffi_vodozemac_bindings_checksum_method_prekeymessage_session_keys(
): Short
fun uniffi_vodozemac_bindings_checksum_method_prekeymessage_to_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_method_prekeymessage_to_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_ratchetpublickey_to_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sas_diffie_hellman(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sas_diffie_hellman_with_raw(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sas_public_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sasbytes_as_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sasbytes_decimals(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sasbytes_emoji_indices(
): Short
fun uniffi_vodozemac_bindings_checksum_method_session_decrypt(
): Short
fun uniffi_vodozemac_bindings_checksum_method_session_encrypt(
): Short
fun uniffi_vodozemac_bindings_checksum_method_session_has_received_message(
): Short
fun uniffi_vodozemac_bindings_checksum_method_session_pickle(
): Short
fun uniffi_vodozemac_bindings_checksum_method_session_session_config(
): Short
fun uniffi_vodozemac_bindings_checksum_method_session_session_id(
): Short
fun uniffi_vodozemac_bindings_checksum_method_session_session_keys(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sessionkey_to_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sessionkey_to_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sessionkeys_base_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sessionkeys_identity_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sessionkeys_one_time_key(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sessionkeys_session_id(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sessionpickle_encrypt(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sharedsecret_as_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sharedsecret_to_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_method_sharedsecret_was_contributory(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_account_from_dehydrated_device(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_account_from_libolm_pickle(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_account_from_pickle(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_account_new(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_accountpickle_from_encrypted(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_curve25519publickey_from_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_curve25519publickey_from_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_curve25519publickey_from_slice(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_curve25519secretkey_from_slice(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_curve25519secretkey_new(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_ecies_new(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_ecies_with_info(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_ed25519keypair_new(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_ed25519publickey_from_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_ed25519publickey_from_slice(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_ed25519secretkey_from_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_ed25519secretkey_from_slice(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_ed25519secretkey_new(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_ed25519signature_from_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_ed25519signature_from_slice(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_exportedsessionkey_from_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_exportedsessionkey_from_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_groupsession_from_pickle(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_groupsession_new(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_groupsession_with_config(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_groupsessionpickle_from_encrypted(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_inboundgroupsession_from_pickle(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_inboundgroupsession_import(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_inboundgroupsession_new(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_inboundgroupsessionpickle_from_encrypted(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_initialmessage_decode(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_keyid_from_u64(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_mac_from_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_mac_from_slice(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_megolmmessage_from_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_megolmmessage_from_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_megolmsessionconfig_version_1(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_megolmsessionconfig_version_2(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_message_decode(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_olmmessage_from_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_olmnormalmessage_from_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_olmnormalmessage_from_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_prekeymessage_from_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_prekeymessage_from_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_ratchetpublickey_from_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_sas_new(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_session_from_libolm_pickle(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_session_from_pickle(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_sessionconfig_default(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_sessionconfig_version_1(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_sessionconfig_version_2(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_sessionkey_from_base64(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_sessionkey_from_bytes(
): Short
fun uniffi_vodozemac_bindings_checksum_constructor_sessionpickle_from_encrypted(
): Short
fun ffi_vodozemac_bindings_uniffi_contract_version(
): Int

}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.
internal interface UniffiLib : Library {
    companion object {
        internal val INSTANCE: UniffiLib by lazy {
            val componentName = "vodozemac"
            // For large crates we prevent `MethodTooLargeException` (see #2340)
            // N.B. the name of the extension is very misleading, since it is 
            // rather `InterfaceTooLargeException`, caused by too many methods 
            // in the interface for large crates.
            //
            // By splitting the otherwise huge interface into two parts
            // * UniffiLib (this)
            // * IntegrityCheckingUniffiLib
            // And all checksum methods are put into `IntegrityCheckingUniffiLib`
            // we allow for ~2x as many methods in the UniffiLib interface.
            // 
            // Thus we first load the library with `loadIndirect` as `IntegrityCheckingUniffiLib`
            // so that we can (optionally!) call `uniffiCheckApiChecksums`...
            loadIndirect<IntegrityCheckingUniffiLib>(componentName)
                .also { lib: IntegrityCheckingUniffiLib ->
                    uniffiCheckContractApiVersion(lib)
                    uniffiCheckApiChecksums(lib)
                }
            // ... and then we load the library as `UniffiLib`
            // N.B. we cannot use `loadIndirect` once and then try to cast it to `UniffiLib`
            // => results in `java.lang.ClassCastException: com.sun.proxy.$Proxy cannot be cast to ...`
            // error. So we must call `loadIndirect` twice. For crates large enough
            // to trigger this issue, the performance impact is negligible, running on
            // a macOS M1 machine the `loadIndirect` call takes ~50ms.
            val lib = loadIndirect<UniffiLib>(componentName)
            // No need to check the contract version and checksums, since 
            // we already did that with `IntegrityCheckingUniffiLib` above.
            // Loading of library with integrity check done.
            lib
        }
        
        // The Cleaner for the whole library
        internal val CLEANER: UniffiCleaner by lazy {
            UniffiCleaner.create()
        }
    }

    // FFI functions
    fun uniffi_vodozemac_bindings_fn_clone_account(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_account(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_account_from_dehydrated_device(`ciphertext`: RustBuffer.ByValue,`nonce`: RustBuffer.ByValue,`key`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_account_from_libolm_pickle(`pickle`: RustBuffer.ByValue,`pickleKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_account_from_pickle(`pickle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_account_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_account_create_inbound_session(`ptr`: Long,`theirIdentityKey`: Long,`preKeyMessage`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_account_create_outbound_session(`ptr`: Long,`sessionConfig`: Long,`identityKey`: Long,`oneTimeKey`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_account_curve25519_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_account_ed25519_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_account_forget_fallback_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_vodozemac_bindings_fn_method_account_generate_fallback_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_account_generate_one_time_keys(`ptr`: Long,`count`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_account_identity_keys(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_account_mark_keys_as_published(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_method_account_max_number_of_one_time_keys(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_account_one_time_keys(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_account_pickle(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_account_sign(`ptr`: Long,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_account_stored_one_time_key_count(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_account_to_dehydrated_device(`ptr`: Long,`key`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_account_to_libolm_pickle(`ptr`: Long,`pickleKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_accountpickle(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_accountpickle(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_accountpickle_from_encrypted(`ciphertext`: RustBuffer.ByValue,`pickleKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_accountpickle_encrypt(`ptr`: Long,`pickleKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_checkcode(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_checkcode(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_method_checkcode_as_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_checkcode_to_digit(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_vodozemac_bindings_fn_clone_curve25519publickey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_curve25519publickey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_curve25519publickey_from_base64(`input`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_curve25519publickey_from_bytes(`bytes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_curve25519publickey_from_slice(`bytes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_curve25519publickey_as_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_curve25519publickey_length(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_vodozemac_bindings_fn_method_curve25519publickey_to_base64(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_curve25519publickey_to_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_curve25519publickey_to_vec(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_curve25519secretkey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_curve25519secretkey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_curve25519secretkey_from_slice(`bytes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_curve25519secretkey_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_curve25519secretkey_diffie_hellman(`ptr`: Long,`theirPublicKey`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_curve25519secretkey_public_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_curve25519secretkey_to_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_decryptedmessage(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_decryptedmessage(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_method_decryptedmessage_message_index(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_vodozemac_bindings_fn_method_decryptedmessage_plaintext(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_ecies(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_ecies(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_ecies_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_ecies_with_info(`info`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_ecies_establish_inbound_channel(`ptr`: Long,`message`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_ecies_establish_outbound_channel(`ptr`: Long,`theirPublicKey`: Long,`initialPlaintext`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_ecies_public_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_clone_ed25519keypair(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_ed25519keypair(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_ed25519keypair_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_ed25519keypair_public_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_ed25519keypair_sign(`ptr`: Long,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_clone_ed25519publickey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_ed25519publickey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_ed25519publickey_from_base64(`input`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_ed25519publickey_from_slice(`bytes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_ed25519publickey_as_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_ed25519publickey_length(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_vodozemac_bindings_fn_method_ed25519publickey_to_base64(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_ed25519publickey_verify(`ptr`: Long,`message`: RustBuffer.ByValue,`signature`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_clone_ed25519secretkey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_ed25519secretkey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_ed25519secretkey_from_base64(`input`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_ed25519secretkey_from_slice(`bytes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_ed25519secretkey_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_ed25519secretkey_length(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_vodozemac_bindings_fn_method_ed25519secretkey_public_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_ed25519secretkey_sign(`ptr`: Long,`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_ed25519secretkey_to_base64(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_ed25519secretkey_to_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_ed25519signature(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_ed25519signature(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_ed25519signature_from_base64(`input`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_ed25519signature_from_slice(`bytes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_ed25519signature_length(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_vodozemac_bindings_fn_method_ed25519signature_to_base64(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_ed25519signature_to_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_establishedecies(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_establishedecies(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_method_establishedecies_check_code(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_establishedecies_decrypt(`ptr`: Long,`message`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_establishedecies_encrypt(`ptr`: Long,`plaintext`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_establishedecies_public_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_clone_establishedsas(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_establishedsas(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_method_establishedsas_bytes(`ptr`: Long,`info`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_establishedsas_bytes_raw(`ptr`: Long,`info`: RustBuffer.ByValue,`count`: Int,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_establishedsas_calculate_mac(`ptr`: Long,`input`: RustBuffer.ByValue,`info`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_establishedsas_calculate_mac_invalid_base64(`ptr`: Long,`input`: RustBuffer.ByValue,`info`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_establishedsas_our_public_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_establishedsas_their_public_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_establishedsas_verify_mac(`ptr`: Long,`input`: RustBuffer.ByValue,`info`: RustBuffer.ByValue,`tag`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_clone_exportedsessionkey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_exportedsessionkey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_exportedsessionkey_from_base64(`input`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_exportedsessionkey_from_bytes(`bytes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_exportedsessionkey_to_base64(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_exportedsessionkey_to_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_groupsession(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_groupsession(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_groupsession_from_pickle(`pickle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_groupsession_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_groupsession_with_config(`config`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_groupsession_encrypt(`ptr`: Long,`plaintext`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_groupsession_message_index(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_vodozemac_bindings_fn_method_groupsession_pickle(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_groupsession_session_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_groupsession_session_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_clone_groupsessionpickle(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_groupsessionpickle(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_groupsessionpickle_from_encrypted(`ciphertext`: RustBuffer.ByValue,`pickleKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_groupsessionpickle_encrypt(`ptr`: Long,`pickleKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_identitykeys(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_identitykeys(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_method_identitykeys_curve25519(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_identitykeys_ed25519(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_clone_inboundcreationresult(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_inboundcreationresult(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_method_inboundcreationresult_ecies(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_inboundcreationresult_message(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_inboundgroupsession(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_inboundgroupsession(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_inboundgroupsession_from_pickle(`pickle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_inboundgroupsession_import(`exportedKey`: Long,`config`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_inboundgroupsession_new(`sessionKey`: Long,`config`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_inboundgroupsession_compare(`ptr`: Long,`other`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_inboundgroupsession_decrypt(`ptr`: Long,`message`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_inboundgroupsession_export_at(`ptr`: Long,`messageIndex`: Int,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_inboundgroupsession_first_known_index(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_vodozemac_bindings_fn_method_inboundgroupsession_pickle(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_inboundgroupsession_session_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_inboundgroupsessionpickle(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_inboundgroupsessionpickle(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_inboundgroupsessionpickle_from_encrypted(`ciphertext`: RustBuffer.ByValue,`pickleKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_inboundgroupsessionpickle_encrypt(`ptr`: Long,`pickleKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_initialmessage(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_initialmessage(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_initialmessage_decode(`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_initialmessage_ciphertext(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_initialmessage_encode(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_initialmessage_public_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_clone_invalidcount(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_invalidcount(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_method_invalidcount_message(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_keyid(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_keyid(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_keyid_from_u64(`value`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_keyid_to_base64(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_mac(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_mac(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_mac_from_base64(`mac`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_mac_from_slice(`bytes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_mac_as_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_mac_to_base64(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_megolmmessage(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_megolmmessage(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_megolmmessage_from_base64(`input`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_megolmmessage_from_bytes(`bytes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_megolmmessage_ciphertext(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_megolmmessage_message_index(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun uniffi_vodozemac_bindings_fn_method_megolmmessage_to_base64(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_megolmmessage_to_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_megolmsessionconfig(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_megolmsessionconfig(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_megolmsessionconfig_version_1(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_megolmsessionconfig_version_2(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_clone_message(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_message(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_message_decode(`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_message_ciphertext(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_message_encode(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_olminboundcreationresult(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_olminboundcreationresult(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_method_olminboundcreationresult_plaintext(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_olminboundcreationresult_session(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_clone_olmmessage(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_olmmessage(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_olmmessage_from_base64(`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_olmmessage_message_type(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_olmmessage_to_base64(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_olmnormalmessage(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_olmnormalmessage(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_olmnormalmessage_from_base64(`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_olmnormalmessage_from_bytes(`bytes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_olmnormalmessage_chain_index(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_olmnormalmessage_ciphertext(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_olmnormalmessage_mac_truncated(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_vodozemac_bindings_fn_method_olmnormalmessage_ratchet_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_olmnormalmessage_to_base64(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_olmnormalmessage_to_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_olmnormalmessage_version(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_vodozemac_bindings_fn_clone_onetimekeygenerationresult(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_onetimekeygenerationresult(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_method_onetimekeygenerationresult_discarded(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_onetimekeygenerationresult_generated(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_onetimekeypair(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_onetimekeypair(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_method_onetimekeypair_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_onetimekeypair_key_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_clone_outboundcreationresult(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_outboundcreationresult(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_method_outboundcreationresult_ecies(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_outboundcreationresult_message(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_clone_prekeymessage(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_prekeymessage(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_prekeymessage_from_base64(`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_prekeymessage_from_bytes(`message`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_prekeymessage_base_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_prekeymessage_identity_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_prekeymessage_message(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_prekeymessage_one_time_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_prekeymessage_session_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_prekeymessage_session_keys(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_prekeymessage_to_base64(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_prekeymessage_to_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_ratchetpublickey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_ratchetpublickey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_ratchetpublickey_from_base64(`key`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_ratchetpublickey_to_base64(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_sas(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_sas(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_sas_new(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_sas_diffie_hellman(`ptr`: Long,`theirPublicKey`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_sas_diffie_hellman_with_raw(`ptr`: Long,`otherPublicKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_sas_public_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_clone_sasbytes(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_sasbytes(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_method_sasbytes_as_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_sasbytes_decimals(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_sasbytes_emoji_indices(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_session(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_session(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_session_from_libolm_pickle(`pickle`: RustBuffer.ByValue,`pickleKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_session_from_pickle(`pickle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_session_decrypt(`ptr`: Long,`message`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_session_encrypt(`ptr`: Long,`plaintext`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_session_has_received_message(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_vodozemac_bindings_fn_method_session_pickle(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_session_session_config(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_session_session_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_session_session_keys(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_clone_sessionconfig(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_sessionconfig(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_sessionconfig_default(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_sessionconfig_version_1(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_sessionconfig_version_2(uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_clone_sessionkey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_sessionkey(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_sessionkey_from_base64(`input`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_constructor_sessionkey_from_bytes(`bytes`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_sessionkey_to_base64(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_sessionkey_to_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_sessionkeys(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_sessionkeys(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_method_sessionkeys_base_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_sessionkeys_identity_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_sessionkeys_one_time_key(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_sessionkeys_session_id(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_sessionpickle(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_sessionpickle(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_constructor_sessionpickle_from_encrypted(`ciphertext`: RustBuffer.ByValue,`pickleKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_method_sessionpickle_encrypt(`ptr`: Long,`pickleKey`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_clone_sharedsecret(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun uniffi_vodozemac_bindings_fn_free_sharedsecret(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun uniffi_vodozemac_bindings_fn_method_sharedsecret_as_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_sharedsecret_to_bytes(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_method_sharedsecret_was_contributory(`ptr`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun uniffi_vodozemac_bindings_fn_func_base64_decode(`input`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_func_base64_encode(`input`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun uniffi_vodozemac_bindings_fn_func_get_version(uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_vodozemac_bindings_rustbuffer_alloc(`size`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_vodozemac_bindings_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_vodozemac_bindings_rustbuffer_free(`buf`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
): Unit
fun ffi_vodozemac_bindings_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_vodozemac_bindings_rust_future_poll_u8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_cancel_u8(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_free_u8(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_complete_u8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun ffi_vodozemac_bindings_rust_future_poll_i8(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_cancel_i8(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_free_i8(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_complete_i8(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Byte
fun ffi_vodozemac_bindings_rust_future_poll_u16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_cancel_u16(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_free_u16(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_complete_u16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
fun ffi_vodozemac_bindings_rust_future_poll_i16(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_cancel_i16(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_free_i16(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_complete_i16(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Short
fun ffi_vodozemac_bindings_rust_future_poll_u32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_cancel_u32(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_free_u32(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_complete_u32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun ffi_vodozemac_bindings_rust_future_poll_i32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_cancel_i32(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_free_i32(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_complete_i32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Int
fun ffi_vodozemac_bindings_rust_future_poll_u64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_cancel_u64(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_free_u64(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_complete_u64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun ffi_vodozemac_bindings_rust_future_poll_i64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_cancel_i64(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_free_i64(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_complete_i64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Long
fun ffi_vodozemac_bindings_rust_future_poll_f32(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_cancel_f32(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_free_f32(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_complete_f32(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Float
fun ffi_vodozemac_bindings_rust_future_poll_f64(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_cancel_f64(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_free_f64(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_complete_f64(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Double
fun ffi_vodozemac_bindings_rust_future_poll_rust_buffer(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_cancel_rust_buffer(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_free_rust_buffer(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_complete_rust_buffer(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): RustBuffer.ByValue
fun ffi_vodozemac_bindings_rust_future_poll_void(`handle`: Long,`callback`: UniffiRustFutureContinuationCallback,`callbackData`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_cancel_void(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_free_void(`handle`: Long,
): Unit
fun ffi_vodozemac_bindings_rust_future_complete_void(`handle`: Long,uniffi_out_err: UniffiRustCallStatus, 
): Unit

}

private fun uniffiCheckContractApiVersion(lib: IntegrityCheckingUniffiLib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_vodozemac_bindings_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}
@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: IntegrityCheckingUniffiLib) {
    if (lib.uniffi_vodozemac_bindings_checksum_func_base64_decode() != 40395.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_func_base64_encode() != 40365.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_func_get_version() != 16884.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_create_inbound_session() != 4017.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_create_outbound_session() != 25411.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_curve25519_key() != 46083.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_ed25519_key() != 25572.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_forget_fallback_key() != 59745.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_generate_fallback_key() != 874.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_generate_one_time_keys() != 60005.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_identity_keys() != 12307.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_mark_keys_as_published() != 19654.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_max_number_of_one_time_keys() != 2024.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_one_time_keys() != 4649.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_pickle() != 63367.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_sign() != 59687.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_stored_one_time_key_count() != 28906.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_to_dehydrated_device() != 55593.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_account_to_libolm_pickle() != 21057.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_accountpickle_encrypt() != 11744.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_checkcode_as_bytes() != 60996.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_checkcode_to_digit() != 44933.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_curve25519publickey_as_bytes() != 31053.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_curve25519publickey_length() != 22847.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_curve25519publickey_to_base64() != 25568.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_curve25519publickey_to_bytes() != 51368.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_curve25519publickey_to_vec() != 30420.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_curve25519secretkey_diffie_hellman() != 35570.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_curve25519secretkey_public_key() != 57764.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_curve25519secretkey_to_bytes() != 6874.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_decryptedmessage_message_index() != 29795.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_decryptedmessage_plaintext() != 2578.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ecies_establish_inbound_channel() != 10409.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ecies_establish_outbound_channel() != 49028.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ecies_public_key() != 16617.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ed25519keypair_public_key() != 59175.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ed25519keypair_sign() != 33429.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ed25519publickey_as_bytes() != 30460.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ed25519publickey_length() != 36441.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ed25519publickey_to_base64() != 16715.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ed25519publickey_verify() != 60604.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ed25519secretkey_length() != 31260.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ed25519secretkey_public_key() != 25167.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ed25519secretkey_sign() != 64533.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ed25519secretkey_to_base64() != 28907.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ed25519secretkey_to_bytes() != 15165.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ed25519signature_length() != 34357.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ed25519signature_to_base64() != 34735.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ed25519signature_to_bytes() != 14918.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_establishedecies_check_code() != 18772.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_establishedecies_decrypt() != 17154.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_establishedecies_encrypt() != 23527.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_establishedecies_public_key() != 37246.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_establishedsas_bytes() != 31486.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_establishedsas_bytes_raw() != 61019.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_establishedsas_calculate_mac() != 55299.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_establishedsas_calculate_mac_invalid_base64() != 55511.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_establishedsas_our_public_key() != 17153.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_establishedsas_their_public_key() != 25334.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_establishedsas_verify_mac() != 16256.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_exportedsessionkey_to_base64() != 1410.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_exportedsessionkey_to_bytes() != 61941.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_groupsession_encrypt() != 7876.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_groupsession_message_index() != 49074.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_groupsession_pickle() != 54089.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_groupsession_session_id() != 43559.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_groupsession_session_key() != 646.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_groupsessionpickle_encrypt() != 28135.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_identitykeys_curve25519() != 63709.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_identitykeys_ed25519() != 44146.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_inboundcreationresult_ecies() != 11349.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_inboundcreationresult_message() != 15609.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_inboundgroupsession_compare() != 5392.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_inboundgroupsession_decrypt() != 28174.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_inboundgroupsession_export_at() != 62832.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_inboundgroupsession_first_known_index() != 31370.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_inboundgroupsession_pickle() != 54411.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_inboundgroupsession_session_id() != 41220.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_inboundgroupsessionpickle_encrypt() != 59401.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_initialmessage_ciphertext() != 7177.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_initialmessage_encode() != 28549.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_initialmessage_public_key() != 50433.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_invalidcount_message() != 59663.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_keyid_to_base64() != 49710.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_mac_as_bytes() != 49616.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_mac_to_base64() != 19443.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_megolmmessage_ciphertext() != 43675.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_megolmmessage_message_index() != 22107.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_megolmmessage_to_base64() != 2385.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_megolmmessage_to_bytes() != 47654.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_message_ciphertext() != 8011.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_message_encode() != 47764.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_olminboundcreationresult_plaintext() != 18673.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_olminboundcreationresult_session() != 19130.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_olmmessage_message_type() != 45969.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_olmmessage_to_base64() != 17800.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_olmnormalmessage_chain_index() != 42997.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_olmnormalmessage_ciphertext() != 63852.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_olmnormalmessage_mac_truncated() != 21565.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_olmnormalmessage_ratchet_key() != 46.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_olmnormalmessage_to_base64() != 9297.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_olmnormalmessage_to_bytes() != 27944.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_olmnormalmessage_version() != 19874.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_onetimekeygenerationresult_discarded() != 63940.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_onetimekeygenerationresult_generated() != 27873.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_onetimekeypair_key() != 25509.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_onetimekeypair_key_id() != 44258.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_outboundcreationresult_ecies() != 10725.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_outboundcreationresult_message() != 48813.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_prekeymessage_base_key() != 25867.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_prekeymessage_identity_key() != 41221.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_prekeymessage_message() != 23572.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_prekeymessage_one_time_key() != 50455.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_prekeymessage_session_id() != 26525.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_prekeymessage_session_keys() != 46810.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_prekeymessage_to_base64() != 38102.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_prekeymessage_to_bytes() != 34591.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_ratchetpublickey_to_base64() != 7033.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sas_diffie_hellman() != 18708.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sas_diffie_hellman_with_raw() != 8967.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sas_public_key() != 5443.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sasbytes_as_bytes() != 29287.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sasbytes_decimals() != 12509.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sasbytes_emoji_indices() != 11506.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_session_decrypt() != 31268.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_session_encrypt() != 40615.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_session_has_received_message() != 50342.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_session_pickle() != 18560.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_session_session_config() != 35093.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_session_session_id() != 16415.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_session_session_keys() != 23544.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sessionkey_to_base64() != 58428.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sessionkey_to_bytes() != 13408.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sessionkeys_base_key() != 40271.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sessionkeys_identity_key() != 32075.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sessionkeys_one_time_key() != 62636.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sessionkeys_session_id() != 51377.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sessionpickle_encrypt() != 40486.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sharedsecret_as_bytes() != 9990.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sharedsecret_to_bytes() != 13349.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_method_sharedsecret_was_contributory() != 30755.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_account_from_dehydrated_device() != 22868.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_account_from_libolm_pickle() != 19721.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_account_from_pickle() != 7541.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_account_new() != 29133.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_accountpickle_from_encrypted() != 27196.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_curve25519publickey_from_base64() != 44436.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_curve25519publickey_from_bytes() != 14862.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_curve25519publickey_from_slice() != 37334.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_curve25519secretkey_from_slice() != 4143.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_curve25519secretkey_new() != 44920.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_ecies_new() != 28587.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_ecies_with_info() != 457.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_ed25519keypair_new() != 55338.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_ed25519publickey_from_base64() != 49198.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_ed25519publickey_from_slice() != 9931.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_ed25519secretkey_from_base64() != 49991.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_ed25519secretkey_from_slice() != 42166.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_ed25519secretkey_new() != 5343.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_ed25519signature_from_base64() != 54087.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_ed25519signature_from_slice() != 57535.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_exportedsessionkey_from_base64() != 3734.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_exportedsessionkey_from_bytes() != 59495.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_groupsession_from_pickle() != 14852.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_groupsession_new() != 33028.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_groupsession_with_config() != 7668.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_groupsessionpickle_from_encrypted() != 20794.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_inboundgroupsession_from_pickle() != 63106.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_inboundgroupsession_import() != 60255.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_inboundgroupsession_new() != 39664.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_inboundgroupsessionpickle_from_encrypted() != 60286.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_initialmessage_decode() != 17149.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_keyid_from_u64() != 55467.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_mac_from_base64() != 60136.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_mac_from_slice() != 34254.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_megolmmessage_from_base64() != 41060.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_megolmmessage_from_bytes() != 2866.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_megolmsessionconfig_version_1() != 44802.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_megolmsessionconfig_version_2() != 29804.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_message_decode() != 46255.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_olmmessage_from_base64() != 18909.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_olmnormalmessage_from_base64() != 24054.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_olmnormalmessage_from_bytes() != 39081.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_prekeymessage_from_base64() != 27497.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_prekeymessage_from_bytes() != 5557.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_ratchetpublickey_from_base64() != 42368.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_sas_new() != 21335.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_session_from_libolm_pickle() != 59596.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_session_from_pickle() != 43585.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_sessionconfig_default() != 21567.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_sessionconfig_version_1() != 62894.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_sessionconfig_version_2() != 6566.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_sessionkey_from_base64() != 53706.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_sessionkey_from_bytes() != 2146.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_vodozemac_bindings_checksum_constructor_sessionpickle_from_encrypted() != 21229.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

/**
 * @suppress
 */
public fun uniffiEnsureInitialized() {
    UniffiLib.INSTANCE
}

// Async support

// Public interface members begin here.


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            for (arg in args) {
                when (arg) {
                    is Disposable -> arg.destroy()
                    is ArrayList<*> -> {
                        for (idx in arg.indices) {
                            val element = arg[idx]
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Map<*, *> -> {
                        for (element in arg.values) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                    is Iterable<*> -> {
                        for (element in arg) {
                            if (element is Disposable) {
                                element.destroy()
                            }
                        }
                    }
                }
            }
        }
    }
}

/**
 * @suppress
 */
inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

/** 
 * Placeholder object used to signal that we're constructing an interface with a FFI handle.
 *
 * This is the first argument for interface constructors that input a raw handle. It exists is that
 * so we can avoid signature conflicts when an interface has a regular constructor than inputs a
 * Long.
 *
 * @suppress
 * */
object UniffiWithHandle

/** 
 * Used to instantiate an interface without an actual pointer, for fakes in tests, mostly.
 *
 * @suppress
 * */
object NoHandle
/**
 * The cleaner interface for Object finalization code to run.
 * This is the entry point to any implementation that we're using.
 *
 * The cleaner registers objects and returns cleanables, so now we are
 * defining a `UniffiCleaner` with a `UniffiClenaer.Cleanable` to abstract the
 * different implmentations available at compile time.
 *
 * @suppress
 */
interface UniffiCleaner {
    interface Cleanable {
        fun clean()
    }

    fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable

    companion object
}

// The fallback Jna cleaner, which is available for both Android, and the JVM.
private class UniffiJnaCleaner : UniffiCleaner {
    private val cleaner = com.sun.jna.internal.Cleaner.getCleaner()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        UniffiJnaCleanable(cleaner.register(value, cleanUpTask))
}

private class UniffiJnaCleanable(
    private val cleanable: com.sun.jna.internal.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}


// We decide at uniffi binding generation time whether we were
// using Android or not.
// There are further runtime checks to chose the correct implementation
// of the cleaner.
private fun UniffiCleaner.Companion.create(): UniffiCleaner =
    try {
        // For safety's sake: if the library hasn't been run in android_cleaner = true
        // mode, but is being run on Android, then we still need to think about
        // Android API versions.
        // So we check if java.lang.ref.Cleaner is there, and use that
        java.lang.Class.forName("java.lang.ref.Cleaner")
        JavaLangRefCleaner()
    } catch (e: ClassNotFoundException) {
        //  otherwise, fallback to the JNA cleaner.
        UniffiJnaCleaner()
    }

private class JavaLangRefCleaner : UniffiCleaner {
    val cleaner = java.lang.ref.Cleaner.create()

    override fun register(value: Any, cleanUpTask: Runnable): UniffiCleaner.Cleanable =
        JavaLangRefCleanable(cleaner.register(value, cleanUpTask))
}

private class JavaLangRefCleanable(
    val cleanable: java.lang.ref.Cleaner.Cleanable
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

/**
 * @suppress
 */
public object FfiConverterUByte: FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte {
        return value.toUByte()
    }

    override fun read(buf: ByteBuffer): UByte {
        return lift(buf.get())
    }

    override fun lower(value: UByte): Byte {
        return value.toByte()
    }

    override fun allocationSize(value: UByte) = 1UL

    override fun write(value: UByte, buf: ByteBuffer) {
        buf.put(value.toByte())
    }
}

/**
 * @suppress
 */
public object FfiConverterUShort: FfiConverter<UShort, Short> {
    override fun lift(value: Short): UShort {
        return value.toUShort()
    }

    override fun read(buf: ByteBuffer): UShort {
        return lift(buf.getShort())
    }

    override fun lower(value: UShort): Short {
        return value.toShort()
    }

    override fun allocationSize(value: UShort) = 2UL

    override fun write(value: UShort, buf: ByteBuffer) {
        buf.putShort(value.toShort())
    }
}

/**
 * @suppress
 */
public object FfiConverterUInt: FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4UL

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

/**
 * @suppress
 */
public object FfiConverterULong: FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8UL

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

/**
 * @suppress
 */
public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1UL

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

/**
 * @suppress
 */
public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len.toInt())
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit().toULong())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): ULong {
        val sizeForLength = 4UL
        val sizeForString = value.length.toULong() * 3UL
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}

/**
 * @suppress
 */
public object FfiConverterByteArray: FfiConverterRustBuffer<ByteArray> {
    override fun read(buf: ByteBuffer): ByteArray {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr
    }
    override fun allocationSize(value: ByteArray): ULong {
        return 4UL + value.size.toULong()
    }
    override fun write(value: ByteArray, buf: ByteBuffer) {
        buf.putInt(value.size)
        buf.put(value)
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * An Olm Account manages all cryptographic keys used on a device.
 */
public interface AccountInterface {
    
    /**
     * Create a Session from the given PreKeyMessage message and identity key
     */
    fun `createInboundSession`(`theirIdentityKey`: Curve25519PublicKey, `preKeyMessage`: PreKeyMessage): OlmInboundCreationResult
    
    /**
     * Create a Session with the given identity key and one-time key.
     */
    fun `createOutboundSession`(`sessionConfig`: SessionConfig, `identityKey`: Curve25519PublicKey, `oneTimeKey`: Curve25519PublicKey): Session
    
    /**
     * Get a copy of the account's public Curve25519 key
     */
    fun `curve25519Key`(): Curve25519PublicKey
    
    /**
     * Get a copy of the account's public Ed25519 key
     */
    fun `ed25519Key`(): Ed25519PublicKey
    
    /**
     * Get the currently unpublished fallback key.
     * The Account stores at most two private parts of the fallback key.
     */
    fun `forgetFallbackKey`(): kotlin.Boolean
    
    /**
     * Generate a single new fallback key.
     */
    fun `generateFallbackKey`(): Curve25519PublicKey?
    
    /**
     * Generates the supplied number of one time keys.
     */
    fun `generateOneTimeKeys`(`count`: kotlin.ULong): OneTimeKeyGenerationResult
    
    /**
     * Get the IdentityKeys of this Account
     */
    fun `identityKeys`(): IdentityKeys
    
    /**
     * Mark all currently unpublished one-time and fallback keys as published.
     */
    fun `markKeysAsPublished`()
    
    /**
     * Get the maximum number of one-time keys the client should keep on the server.
     */
    fun `maxNumberOfOneTimeKeys`(): kotlin.ULong
    
    /**
     * Get the currently unpublished one-time keys.
     */
    fun `oneTimeKeys`(): List<OneTimeKeyPair>
    
    /**
     * Convert the account into a struct which implements serde::Serialize and serde::Deserialize.
     */
    fun `pickle`(): AccountPickle
    
    /**
     * Sign the given message using our Ed25519 identity key.
     */
    fun `sign`(`message`: kotlin.ByteArray): Ed25519Signature
    
    /**
     * Get the number of one-time keys we have stored locally.
     */
    fun `storedOneTimeKeyCount`(): kotlin.ULong
    
    /**
     * Create a dehydrated device from the account.
     */
    fun `toDehydratedDevice`(`key`: kotlin.ByteArray): DehydratedDeviceResult
    
    /**
     * Pickle an Account into a libolm pickle format.
     */
    fun `toLibolmPickle`(`pickleKey`: kotlin.ByteArray): kotlin.String
    
    companion object
}

/**
 * An Olm Account manages all cryptographic keys used on a device.
 */
open class Account: Disposable, AutoCloseable, AccountInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    /**
     * Create a new Account with fresh identity and one-time keys.
     */
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_account_new(
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_account(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_account(handle, status)
        }
    }

    
    /**
     * Create a Session from the given PreKeyMessage message and identity key
     */
    @Throws(VodozemacException::class)override fun `createInboundSession`(`theirIdentityKey`: Curve25519PublicKey, `preKeyMessage`: PreKeyMessage): OlmInboundCreationResult {
            return FfiConverterTypeOlmInboundCreationResult.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_create_inbound_session(
        it, FfiConverterTypeCurve25519PublicKey.lower(`theirIdentityKey`),FfiConverterTypePreKeyMessage.lower(`preKeyMessage`),_status)
}
    }
    )
    }
    

    
    /**
     * Create a Session with the given identity key and one-time key.
     */override fun `createOutboundSession`(`sessionConfig`: SessionConfig, `identityKey`: Curve25519PublicKey, `oneTimeKey`: Curve25519PublicKey): Session {
            return FfiConverterTypeSession.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_create_outbound_session(
        it, FfiConverterTypeSessionConfig.lower(`sessionConfig`),FfiConverterTypeCurve25519PublicKey.lower(`identityKey`),FfiConverterTypeCurve25519PublicKey.lower(`oneTimeKey`),_status)
}
    }
    )
    }
    

    
    /**
     * Get a copy of the account's public Curve25519 key
     */override fun `curve25519Key`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_curve25519_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get a copy of the account's public Ed25519 key
     */override fun `ed25519Key`(): Ed25519PublicKey {
            return FfiConverterTypeEd25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_ed25519_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the currently unpublished fallback key.
     * The Account stores at most two private parts of the fallback key.
     */override fun `forgetFallbackKey`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_forget_fallback_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Generate a single new fallback key.
     */override fun `generateFallbackKey`(): Curve25519PublicKey? {
            return FfiConverterOptionalTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_generate_fallback_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Generates the supplied number of one time keys.
     */override fun `generateOneTimeKeys`(`count`: kotlin.ULong): OneTimeKeyGenerationResult {
            return FfiConverterTypeOneTimeKeyGenerationResult.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_generate_one_time_keys(
        it, FfiConverterULong.lower(`count`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the IdentityKeys of this Account
     */override fun `identityKeys`(): IdentityKeys {
            return FfiConverterTypeIdentityKeys.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_identity_keys(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Mark all currently unpublished one-time and fallback keys as published.
     */override fun `markKeysAsPublished`()
        = 
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_mark_keys_as_published(
        it, _status)
}
    }
    
    

    
    /**
     * Get the maximum number of one-time keys the client should keep on the server.
     */override fun `maxNumberOfOneTimeKeys`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_max_number_of_one_time_keys(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the currently unpublished one-time keys.
     */override fun `oneTimeKeys`(): List<OneTimeKeyPair> {
            return FfiConverterSequenceTypeOneTimeKeyPair.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_one_time_keys(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Convert the account into a struct which implements serde::Serialize and serde::Deserialize.
     */override fun `pickle`(): AccountPickle {
            return FfiConverterTypeAccountPickle.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_pickle(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Sign the given message using our Ed25519 identity key.
     */override fun `sign`(`message`: kotlin.ByteArray): Ed25519Signature {
            return FfiConverterTypeEd25519Signature.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_sign(
        it, FfiConverterByteArray.lower(`message`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the number of one-time keys we have stored locally.
     */override fun `storedOneTimeKeyCount`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_stored_one_time_key_count(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Create a dehydrated device from the account.
     */
    @Throws(VodozemacException::class)override fun `toDehydratedDevice`(`key`: kotlin.ByteArray): DehydratedDeviceResult {
            return FfiConverterTypeDehydratedDeviceResult.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_to_dehydrated_device(
        it, FfiConverterByteArray.lower(`key`),_status)
}
    }
    )
    }
    

    
    /**
     * Pickle an Account into a libolm pickle format.
     */
    @Throws(VodozemacException::class)override fun `toLibolmPickle`(`pickleKey`: kotlin.ByteArray): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_account_to_libolm_pickle(
        it, FfiConverterByteArray.lower(`pickleKey`),_status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create an Account object from a dehydrated device.
     */
    @Throws(VodozemacException::class) fun `fromDehydratedDevice`(`ciphertext`: kotlin.String, `nonce`: kotlin.String, `key`: kotlin.ByteArray): Account {
            return FfiConverterTypeAccount.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_account_from_dehydrated_device(
        FfiConverterString.lower(`ciphertext`),FfiConverterString.lower(`nonce`),FfiConverterByteArray.lower(`key`),_status)
}
    )
    }
    

        
    /**
     * Create an Account object by unpickling an account pickle in libolm legacy pickle format.
     */
    @Throws(VodozemacException::class) fun `fromLibolmPickle`(`pickle`: kotlin.String, `pickleKey`: kotlin.ByteArray): Account {
            return FfiConverterTypeAccount.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_account_from_libolm_pickle(
        FfiConverterString.lower(`pickle`),FfiConverterByteArray.lower(`pickleKey`),_status)
}
    )
    }
    

        
    /**
     * Restore an Account from a previously saved AccountPickle.
     */
    @Throws(VodozemacException::class) fun `fromPickle`(`pickle`: AccountPickle): Account {
            return FfiConverterTypeAccount.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_account_from_pickle(
        FfiConverterTypeAccountPickle.lower(`pickle`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeAccount: FfiConverter<Account, Long> {
    override fun lower(value: Account): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Account {
        return Account(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Account {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Account) = 8UL

    override fun write(value: Account, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * A struct representing the pickled Account.
 */
public interface AccountPickleInterface {
    
    /**
     * Serialize and encrypt the pickle using the given key.
     */
    fun `encrypt`(`pickleKey`: kotlin.ByteArray): kotlin.String
    
    companion object
}

/**
 * A struct representing the pickled Account.
 */
open class AccountPickle: Disposable, AutoCloseable, AccountPickleInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_accountpickle(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_accountpickle(handle, status)
        }
    }

    
    /**
     * Serialize and encrypt the pickle using the given key.
     */
    @Throws(VodozemacException::class)override fun `encrypt`(`pickleKey`: kotlin.ByteArray): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_accountpickle_encrypt(
        it, FfiConverterByteArray.lower(`pickleKey`),_status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Obtain a pickle from a ciphertext by decrypting and deserializing using the given key.
     */
    @Throws(VodozemacException::class) fun `fromEncrypted`(`ciphertext`: kotlin.String, `pickleKey`: kotlin.ByteArray): AccountPickle {
            return FfiConverterTypeAccountPickle.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_accountpickle_from_encrypted(
        FfiConverterString.lower(`ciphertext`),FfiConverterByteArray.lower(`pickleKey`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeAccountPickle: FfiConverter<AccountPickle, Long> {
    override fun lower(value: AccountPickle): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): AccountPickle {
        return AccountPickle(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): AccountPickle {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: AccountPickle) = 8UL

    override fun write(value: AccountPickle, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * A check code that can be used to confirm that two EstablishedEcies
 * objects share the same secret. This is supposed to be shared out-of-band to
 * protect against active MITM attacks.
 */
public interface CheckCodeInterface {
    
    /**
     * Convert the check code to a Vec of two bytes.
     * UniFFI doesn't support fixed arrays, so we return a Vec.
     */
    fun `asBytes`(): kotlin.ByteArray
    
    /**
     * Convert the check code to two base-10 numbers.
     * The number should be displayed with a leading 0 in case the first digit is a 0.
     */
    fun `toDigit`(): kotlin.UByte
    
    companion object
}

/**
 * A check code that can be used to confirm that two EstablishedEcies
 * objects share the same secret. This is supposed to be shared out-of-band to
 * protect against active MITM attacks.
 */
open class CheckCode: Disposable, AutoCloseable, CheckCodeInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_checkcode(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_checkcode(handle, status)
        }
    }

    
    /**
     * Convert the check code to a Vec of two bytes.
     * UniFFI doesn't support fixed arrays, so we return a Vec.
     */override fun `asBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_checkcode_as_bytes(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Convert the check code to two base-10 numbers.
     * The number should be displayed with a leading 0 in case the first digit is a 0.
     */override fun `toDigit`(): kotlin.UByte {
            return FfiConverterUByte.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_checkcode_to_digit(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeCheckCode: FfiConverter<CheckCode, Long> {
    override fun lower(value: CheckCode): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): CheckCode {
        return CheckCode(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): CheckCode {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: CheckCode) = 8UL

    override fun write(value: CheckCode, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * Wrapper around vodozemac::Curve25519PublicKey
 *
 * Pattern: Complex object with multiple constructors, error handling, and various return types
 */
public interface Curve25519PublicKeyInterface {
    
    /**
     * View the public key as bytes
     *
     * Pattern: Method returning Vec<u8> (mapped to Swift Data)
     */
    fun `asBytes`(): kotlin.ByteArray
    
    /**
     * Return the length in bytes of a Curve25519 public key (parity with Rust LENGTH const).
     */
    fun `length`(): kotlin.UInt
    
    /**
     * Convert the public key to a base64 string
     *
     * Pattern: Method returning primitive type (String)
     */
    fun `toBase64`(): kotlin.String
    
    /**
     * Convert the public key to bytes
     *
     * Pattern: Method returning Vec<u8> (mapped to Swift Data)
     */
    fun `toBytes`(): kotlin.ByteArray
    
    /**
     * Convert the public key to a vector of bytes
     *
     * Pattern: Method returning Vec<u8> (mapped to Swift Data)
     */
    fun `toVec`(): kotlin.ByteArray
    
    companion object
}

/**
 * Wrapper around vodozemac::Curve25519PublicKey
 *
 * Pattern: Complex object with multiple constructors, error handling, and various return types
 */
open class Curve25519PublicKey: Disposable, AutoCloseable, Curve25519PublicKeyInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_curve25519publickey(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_curve25519publickey(handle, status)
        }
    }

    
    /**
     * View the public key as bytes
     *
     * Pattern: Method returning Vec<u8> (mapped to Swift Data)
     */override fun `asBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_curve25519publickey_as_bytes(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Return the length in bytes of a Curve25519 public key (parity with Rust LENGTH const).
     */override fun `length`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_curve25519publickey_length(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Convert the public key to a base64 string
     *
     * Pattern: Method returning primitive type (String)
     */override fun `toBase64`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_curve25519publickey_to_base64(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Convert the public key to bytes
     *
     * Pattern: Method returning Vec<u8> (mapped to Swift Data)
     */override fun `toBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_curve25519publickey_to_bytes(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Convert the public key to a vector of bytes
     *
     * Pattern: Method returning Vec<u8> (mapped to Swift Data)
     */override fun `toVec`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_curve25519publickey_to_vec(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create a Curve25519PublicKey from a base64 string
     *
     * Pattern: Fallible constructor with error handling
     */
    @Throws(VodozemacException::class) fun `fromBase64`(`input`: kotlin.String): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_curve25519publickey_from_base64(
        FfiConverterString.lower(`input`),_status)
}
    )
    }
    

        
    /**
     * Create a Curve25519PublicKey from exactly 32 bytes
     *
     * Pattern: Infallible constructor (panics on invalid input)
     */ fun `fromBytes`(`bytes`: kotlin.ByteArray): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_curve25519publickey_from_bytes(
        FfiConverterByteArray.lower(`bytes`),_status)
}
    )
    }
    

        
    /**
     * Create a Curve25519PublicKey from a slice of bytes
     *
     * Pattern: Fallible constructor with error handling
     */
    @Throws(VodozemacException::class) fun `fromSlice`(`bytes`: kotlin.ByteArray): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_curve25519publickey_from_slice(
        FfiConverterByteArray.lower(`bytes`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeCurve25519PublicKey: FfiConverter<Curve25519PublicKey, Long> {
    override fun lower(value: Curve25519PublicKey): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Curve25519PublicKey {
        return Curve25519PublicKey(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Curve25519PublicKey {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Curve25519PublicKey) = 8UL

    override fun write(value: Curve25519PublicKey, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * Wrapper around vodozemac::Curve25519SecretKey
 *
 * Pattern: Object that returns other objects (demonstrates Arc<OtherObject> pattern)
 */
public interface Curve25519SecretKeyInterface {
    
    /**
     * Perform a Diffie-Hellman key exchange with the given public key.
     *
     * Returns a SharedSecret that can be inspected or used by higher-level protocols.
     */
    fun `diffieHellman`(`theirPublicKey`: Curve25519PublicKey): SharedSecret
    
    /**
     * Get the public key that corresponds to this secret key
     *
     * Pattern: Method returning Arc<AnotherObject> - CRITICAL for UniFFI
     */
    fun `publicKey`(): Curve25519PublicKey
    
    /**
     * Convert the secret key to bytes
     *
     * Pattern: Method returning Vec<u8>
     */
    fun `toBytes`(): kotlin.ByteArray
    
    companion object
}

/**
 * Wrapper around vodozemac::Curve25519SecretKey
 *
 * Pattern: Object that returns other objects (demonstrates Arc<OtherObject> pattern)
 */
open class Curve25519SecretKey: Disposable, AutoCloseable, Curve25519SecretKeyInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    /**
     * Generate a new random Curve25519SecretKey
     *
     * Pattern: Simple constructor with no parameters
     */
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_curve25519secretkey_new(
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_curve25519secretkey(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_curve25519secretkey(handle, status)
        }
    }

    
    /**
     * Perform a Diffie-Hellman key exchange with the given public key.
     *
     * Returns a SharedSecret that can be inspected or used by higher-level protocols.
     */override fun `diffieHellman`(`theirPublicKey`: Curve25519PublicKey): SharedSecret {
            return FfiConverterTypeSharedSecret.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_curve25519secretkey_diffie_hellman(
        it, FfiConverterTypeCurve25519PublicKey.lower(`theirPublicKey`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the public key that corresponds to this secret key
     *
     * Pattern: Method returning Arc<AnotherObject> - CRITICAL for UniFFI
     */override fun `publicKey`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_curve25519secretkey_public_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Convert the secret key to bytes
     *
     * Pattern: Method returning Vec<u8>
     */override fun `toBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_curve25519secretkey_to_bytes(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create a Curve25519SecretKey from exactly 32 bytes
     *
     * Pattern: Constructor with validation (panics on invalid input)
     */ fun `fromSlice`(`bytes`: kotlin.ByteArray): Curve25519SecretKey {
            return FfiConverterTypeCurve25519SecretKey.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_curve25519secretkey_from_slice(
        FfiConverterByteArray.lower(`bytes`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeCurve25519SecretKey: FfiConverter<Curve25519SecretKey, Long> {
    override fun lower(value: Curve25519SecretKey): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Curve25519SecretKey {
        return Curve25519SecretKey(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Curve25519SecretKey {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Curve25519SecretKey) = 8UL

    override fun write(value: Curve25519SecretKey, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * A message successfully decrypted by an InboundGroupSession
 *
 * Contains the decrypted plaintext and the message index to prevent replay attacks
 */
public interface DecryptedMessageInterface {
    
    /**
     * Get the message index used to encrypt this message
     *
     * Each plaintext message should be encrypted with a unique message index per session
     */
    fun `messageIndex`(): kotlin.UInt
    
    /**
     * Get the decrypted plaintext bytes
     */
    fun `plaintext`(): kotlin.ByteArray
    
    companion object
}

/**
 * A message successfully decrypted by an InboundGroupSession
 *
 * Contains the decrypted plaintext and the message index to prevent replay attacks
 */
open class DecryptedMessage: Disposable, AutoCloseable, DecryptedMessageInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_decryptedmessage(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_decryptedmessage(handle, status)
        }
    }

    
    /**
     * Get the message index used to encrypt this message
     *
     * Each plaintext message should be encrypted with a unique message index per session
     */override fun `messageIndex`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_decryptedmessage_message_index(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the decrypted plaintext bytes
     */override fun `plaintext`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_decryptedmessage_plaintext(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeDecryptedMessage: FfiConverter<DecryptedMessage, Long> {
    override fun lower(value: DecryptedMessage): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): DecryptedMessage {
        return DecryptedMessage(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): DecryptedMessage {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: DecryptedMessage) = 8UL

    override fun write(value: DecryptedMessage, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * An unestablished ECIES session.
 */
public interface EciesInterface {
    
    /**
     * Create an EstablishedEcies from an InitialMessage encrypted by the other side.
     */
    fun `establishInboundChannel`(`message`: InitialMessage): InboundCreationResult
    
    /**
     * Create an EstablishedEcies session using the other side's Curve25519
     * public key and an initial plaintext.
     */
    fun `establishOutboundChannel`(`theirPublicKey`: Curve25519PublicKey, `initialPlaintext`: kotlin.ByteArray): OutboundCreationResult
    
    /**
     * Get our Curve25519PublicKey.
     * This public key needs to be sent to the other side to establish an ECIES channel.
     */
    fun `publicKey`(): Curve25519PublicKey
    
    companion object
}

/**
 * An unestablished ECIES session.
 */
open class Ecies: Disposable, AutoCloseable, EciesInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    /**
     * Create a new, random, unestablished ECIES session.
     * This method will use the `MATRIX_QR_CODE_LOGIN` info.
     */
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_ecies_new(
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_ecies(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_ecies(handle, status)
        }
    }

    
    /**
     * Create an EstablishedEcies from an InitialMessage encrypted by the other side.
     */
    @Throws(VodozemacException::class)override fun `establishInboundChannel`(`message`: InitialMessage): InboundCreationResult {
            return FfiConverterTypeInboundCreationResult.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ecies_establish_inbound_channel(
        it, FfiConverterTypeInitialMessage.lower(`message`),_status)
}
    }
    )
    }
    

    
    /**
     * Create an EstablishedEcies session using the other side's Curve25519
     * public key and an initial plaintext.
     */
    @Throws(VodozemacException::class)override fun `establishOutboundChannel`(`theirPublicKey`: Curve25519PublicKey, `initialPlaintext`: kotlin.ByteArray): OutboundCreationResult {
            return FfiConverterTypeOutboundCreationResult.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ecies_establish_outbound_channel(
        it, FfiConverterTypeCurve25519PublicKey.lower(`theirPublicKey`),FfiConverterByteArray.lower(`initialPlaintext`),_status)
}
    }
    )
    }
    

    
    /**
     * Get our Curve25519PublicKey.
     * This public key needs to be sent to the other side to establish an ECIES channel.
     */
    @Throws(VodozemacException::class)override fun `publicKey`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ecies_public_key(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create a new, random, unestablished ECIES session with the given application info.
     */ fun `withInfo`(`info`: kotlin.String): Ecies {
            return FfiConverterTypeEcies.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_ecies_with_info(
        FfiConverterString.lower(`info`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeEcies: FfiConverter<Ecies, Long> {
    override fun lower(value: Ecies): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Ecies {
        return Ecies(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Ecies {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Ecies) = 8UL

    override fun write(value: Ecies, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * Wrapper around vodozemac::Ed25519Keypair
 *
 * Ed25519 keypair containing both public and secret keys for digital signatures
 */
public interface Ed25519KeypairInterface {
    
    /**
     * Get the public key from this keypair
     *
     * Pattern: Method returning Arc<AnotherObject>
     */
    fun `publicKey`(): Ed25519PublicKey
    
    /**
     * Sign a message with the secret key from this keypair
     *
     * Pattern: Method taking bytes and returning Arc<AnotherObject>
     */
    fun `sign`(`message`: kotlin.ByteArray): Ed25519Signature
    
    companion object
}

/**
 * Wrapper around vodozemac::Ed25519Keypair
 *
 * Ed25519 keypair containing both public and secret keys for digital signatures
 */
open class Ed25519Keypair: Disposable, AutoCloseable, Ed25519KeypairInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    /**
     * Generate a new random Ed25519 keypair
     *
     * Pattern: Simple constructor with no parameters
     */
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_ed25519keypair_new(
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_ed25519keypair(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_ed25519keypair(handle, status)
        }
    }

    
    /**
     * Get the public key from this keypair
     *
     * Pattern: Method returning Arc<AnotherObject>
     */override fun `publicKey`(): Ed25519PublicKey {
            return FfiConverterTypeEd25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ed25519keypair_public_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Sign a message with the secret key from this keypair
     *
     * Pattern: Method taking bytes and returning Arc<AnotherObject>
     */override fun `sign`(`message`: kotlin.ByteArray): Ed25519Signature {
            return FfiConverterTypeEd25519Signature.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ed25519keypair_sign(
        it, FfiConverterByteArray.lower(`message`),_status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeEd25519Keypair: FfiConverter<Ed25519Keypair, Long> {
    override fun lower(value: Ed25519Keypair): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Ed25519Keypair {
        return Ed25519Keypair(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Ed25519Keypair {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Ed25519Keypair) = 8UL

    override fun write(value: Ed25519Keypair, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * Wrapper around vodozemac::Ed25519PublicKey
 *
 * Ed25519 public key used to verify digital signatures
 */
public interface Ed25519PublicKeyInterface {
    
    /**
     * View this public key as a byte array
     *
     * Pattern: Method returning Vec<u8>
     */
    fun `asBytes`(): kotlin.ByteArray
    
    /**
     * Return the length in bytes of an Ed25519 public key (parity with Rust LENGTH const).
     */
    fun `length`(): kotlin.UInt
    
    /**
     * Convert the public key to a base64 string
     *
     * Pattern: Method returning primitive type (String)
     */
    fun `toBase64`(): kotlin.String
    
    /**
     * Verify that the provided signature for a message was signed by this key
     *
     * Pattern: Method with complex parameters, returns Result
     */
    fun `verify`(`message`: kotlin.ByteArray, `signature`: Ed25519Signature)
    
    companion object
}

/**
 * Wrapper around vodozemac::Ed25519PublicKey
 *
 * Ed25519 public key used to verify digital signatures
 */
open class Ed25519PublicKey: Disposable, AutoCloseable, Ed25519PublicKeyInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_ed25519publickey(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_ed25519publickey(handle, status)
        }
    }

    
    /**
     * View this public key as a byte array
     *
     * Pattern: Method returning Vec<u8>
     */override fun `asBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ed25519publickey_as_bytes(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Return the length in bytes of an Ed25519 public key (parity with Rust LENGTH const).
     */override fun `length`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ed25519publickey_length(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Convert the public key to a base64 string
     *
     * Pattern: Method returning primitive type (String)
     */override fun `toBase64`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ed25519publickey_to_base64(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Verify that the provided signature for a message was signed by this key
     *
     * Pattern: Method with complex parameters, returns Result
     */
    @Throws(VodozemacException::class)override fun `verify`(`message`: kotlin.ByteArray, `signature`: Ed25519Signature)
        = 
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ed25519publickey_verify(
        it, FfiConverterByteArray.lower(`message`),FfiConverterTypeEd25519Signature.lower(`signature`),_status)
}
    }
    
    

    

    
    companion object {
        
    /**
     * Create an Ed25519PublicKey from a base64 string
     *
     * Pattern: Fallible constructor with error handling
     */
    @Throws(VodozemacException::class) fun `fromBase64`(`input`: kotlin.String): Ed25519PublicKey {
            return FfiConverterTypeEd25519PublicKey.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_ed25519publickey_from_base64(
        FfiConverterString.lower(`input`),_status)
}
    )
    }
    

        
    /**
     * Create an Ed25519PublicKey from a slice of bytes
     *
     * Pattern: Fallible constructor with error handling
     */
    @Throws(VodozemacException::class) fun `fromSlice`(`bytes`: kotlin.ByteArray): Ed25519PublicKey {
            return FfiConverterTypeEd25519PublicKey.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_ed25519publickey_from_slice(
        FfiConverterByteArray.lower(`bytes`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeEd25519PublicKey: FfiConverter<Ed25519PublicKey, Long> {
    override fun lower(value: Ed25519PublicKey): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Ed25519PublicKey {
        return Ed25519PublicKey(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Ed25519PublicKey {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Ed25519PublicKey) = 8UL

    override fun write(value: Ed25519PublicKey, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * Wrapper around vodozemac::Ed25519SecretKey
 *
 * Ed25519 secret key used to create digital signatures
 */
public interface Ed25519SecretKeyInterface {
    
    /**
     * Return the length in bytes of an Ed25519 secret key (parity with Rust LENGTH const).
     */
    fun `length`(): kotlin.UInt
    
    /**
     * Get the public key that matches this secret key
     *
     * Pattern: Method returning Arc<AnotherObject>
     */
    fun `publicKey`(): Ed25519PublicKey
    
    /**
     * Sign the given slice of bytes with this secret key
     *
     * Pattern: Method taking bytes and returning Arc<AnotherObject>
     */
    fun `sign`(`message`: kotlin.ByteArray): Ed25519Signature
    
    /**
     * Convert the secret key to a base64 encoded string
     *
     * Pattern: Method returning primitive type (String)
     */
    fun `toBase64`(): kotlin.String
    
    /**
     * Get the byte representation of the secret key
     *
     * Pattern: Method returning Vec<u8> (Box<[u8; 32]> is converted to Vec<u8>)
     */
    fun `toBytes`(): kotlin.ByteArray
    
    companion object
}

/**
 * Wrapper around vodozemac::Ed25519SecretKey
 *
 * Ed25519 secret key used to create digital signatures
 */
open class Ed25519SecretKey: Disposable, AutoCloseable, Ed25519SecretKeyInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    /**
     * Generate a new random Ed25519 secret key
     *
     * Pattern: Simple constructor with no parameters
     */
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_ed25519secretkey_new(
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_ed25519secretkey(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_ed25519secretkey(handle, status)
        }
    }

    
    /**
     * Return the length in bytes of an Ed25519 secret key (parity with Rust LENGTH const).
     */override fun `length`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ed25519secretkey_length(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the public key that matches this secret key
     *
     * Pattern: Method returning Arc<AnotherObject>
     */override fun `publicKey`(): Ed25519PublicKey {
            return FfiConverterTypeEd25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ed25519secretkey_public_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Sign the given slice of bytes with this secret key
     *
     * Pattern: Method taking bytes and returning Arc<AnotherObject>
     */override fun `sign`(`message`: kotlin.ByteArray): Ed25519Signature {
            return FfiConverterTypeEd25519Signature.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ed25519secretkey_sign(
        it, FfiConverterByteArray.lower(`message`),_status)
}
    }
    )
    }
    

    
    /**
     * Convert the secret key to a base64 encoded string
     *
     * Pattern: Method returning primitive type (String)
     */override fun `toBase64`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ed25519secretkey_to_base64(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the byte representation of the secret key
     *
     * Pattern: Method returning Vec<u8> (Box<[u8; 32]> is converted to Vec<u8>)
     */override fun `toBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ed25519secretkey_to_bytes(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create an Ed25519SecretKey from a base64 string
     *
     * Pattern: Fallible constructor with error handling
     */
    @Throws(VodozemacException::class) fun `fromBase64`(`input`: kotlin.String): Ed25519SecretKey {
            return FfiConverterTypeEd25519SecretKey.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_ed25519secretkey_from_base64(
        FfiConverterString.lower(`input`),_status)
}
    )
    }
    

        
    /**
     * Create an Ed25519SecretKey from a slice of bytes
     *
     * Pattern: Constructor with validation
     */
    @Throws(VodozemacException::class) fun `fromSlice`(`bytes`: kotlin.ByteArray): Ed25519SecretKey {
            return FfiConverterTypeEd25519SecretKey.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_ed25519secretkey_from_slice(
        FfiConverterByteArray.lower(`bytes`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeEd25519SecretKey: FfiConverter<Ed25519SecretKey, Long> {
    override fun lower(value: Ed25519SecretKey): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Ed25519SecretKey {
        return Ed25519SecretKey(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Ed25519SecretKey {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Ed25519SecretKey) = 8UL

    override fun write(value: Ed25519SecretKey, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * Wrapper around vodozemac::Ed25519Signature
 *
 * Ed25519 digital signature that can be used to verify message authenticity
 */
public interface Ed25519SignatureInterface {
    
    /**
     * Return the length in bytes of an Ed25519 signature (parity with Rust LENGTH const).
     */
    fun `length`(): kotlin.UInt
    
    /**
     * Convert the signature to a base64 encoded string
     *
     * Pattern: Method returning primitive type (String)
     */
    fun `toBase64`(): kotlin.String
    
    /**
     * Convert the signature to a byte array
     *
     * Pattern: Method returning Vec<u8>
     */
    fun `toBytes`(): kotlin.ByteArray
    
    companion object
}

/**
 * Wrapper around vodozemac::Ed25519Signature
 *
 * Ed25519 digital signature that can be used to verify message authenticity
 */
open class Ed25519Signature: Disposable, AutoCloseable, Ed25519SignatureInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_ed25519signature(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_ed25519signature(handle, status)
        }
    }

    
    /**
     * Return the length in bytes of an Ed25519 signature (parity with Rust LENGTH const).
     */override fun `length`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ed25519signature_length(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Convert the signature to a base64 encoded string
     *
     * Pattern: Method returning primitive type (String)
     */override fun `toBase64`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ed25519signature_to_base64(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Convert the signature to a byte array
     *
     * Pattern: Method returning Vec<u8>
     */override fun `toBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ed25519signature_to_bytes(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create an Ed25519Signature from a base64 string
     *
     * Pattern: Fallible constructor with error handling
     */
    @Throws(VodozemacException::class) fun `fromBase64`(`input`: kotlin.String): Ed25519Signature {
            return FfiConverterTypeEd25519Signature.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_ed25519signature_from_base64(
        FfiConverterString.lower(`input`),_status)
}
    )
    }
    

        
    /**
     * Create an Ed25519Signature from a slice of bytes
     *
     * Pattern: Fallible constructor with error handling
     */
    @Throws(VodozemacException::class) fun `fromSlice`(`bytes`: kotlin.ByteArray): Ed25519Signature {
            return FfiConverterTypeEd25519Signature.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_ed25519signature_from_slice(
        FfiConverterByteArray.lower(`bytes`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeEd25519Signature: FfiConverter<Ed25519Signature, Long> {
    override fun lower(value: Ed25519Signature): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Ed25519Signature {
        return Ed25519Signature(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Ed25519Signature {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Ed25519Signature) = 8UL

    override fun write(value: Ed25519Signature, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * An established ECIES session.
 * This session can be used to encrypt and decrypt messages between the two
 * sides of the channel.
 */
public interface EstablishedEciesInterface {
    
    /**
     * Get the CheckCode which uniquely identifies this EstablishedEcies session.
     * This check code can be used to check that both sides of the session are
     * indeed using the same shared secret.
     */
    fun `checkCode`(): CheckCode
    
    /**
     * Decrypt the given message using this EstablishedEcies session.
     */
    fun `decrypt`(`message`: Message): kotlin.ByteArray
    
    /**
     * Encrypt the given plaintext using this EstablishedEcies session.
     */
    fun `encrypt`(`plaintext`: kotlin.ByteArray): Message
    
    /**
     * Get our Curve25519PublicKey.
     * This public key needs to be sent to the other side so that it can
     * complete the ECIES channel establishment.
     */
    fun `publicKey`(): Curve25519PublicKey
    
    companion object
}

/**
 * An established ECIES session.
 * This session can be used to encrypt and decrypt messages between the two
 * sides of the channel.
 */
open class EstablishedEcies: Disposable, AutoCloseable, EstablishedEciesInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_establishedecies(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_establishedecies(handle, status)
        }
    }

    
    /**
     * Get the CheckCode which uniquely identifies this EstablishedEcies session.
     * This check code can be used to check that both sides of the session are
     * indeed using the same shared secret.
     */override fun `checkCode`(): CheckCode {
            return FfiConverterTypeCheckCode.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_establishedecies_check_code(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Decrypt the given message using this EstablishedEcies session.
     */
    @Throws(VodozemacException::class)override fun `decrypt`(`message`: Message): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_establishedecies_decrypt(
        it, FfiConverterTypeMessage.lower(`message`),_status)
}
    }
    )
    }
    

    
    /**
     * Encrypt the given plaintext using this EstablishedEcies session.
     */
    @Throws(VodozemacException::class)override fun `encrypt`(`plaintext`: kotlin.ByteArray): Message {
            return FfiConverterTypeMessage.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_establishedecies_encrypt(
        it, FfiConverterByteArray.lower(`plaintext`),_status)
}
    }
    )
    }
    

    
    /**
     * Get our Curve25519PublicKey.
     * This public key needs to be sent to the other side so that it can
     * complete the ECIES channel establishment.
     */override fun `publicKey`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_establishedecies_public_key(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeEstablishedEcies: FfiConverter<EstablishedEcies, Long> {
    override fun lower(value: EstablishedEcies): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): EstablishedEcies {
        return EstablishedEcies(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): EstablishedEcies {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: EstablishedEcies) = 8UL

    override fun write(value: EstablishedEcies, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * A struct representing a short auth string verification object where the
 * shared secret has been established.
 */
public interface EstablishedSasInterface {
    
    /**
     * Generate SasBytes using HKDF with the shared secret as the input key material.
     *
     * The info string should be agreed upon beforehand, both parties need to
     * use the same info string.
     */
    fun `bytes`(`info`: kotlin.String): SasBytes
    
    /**
     * Generate the given number of bytes using HKDF with the shared secret
     * as the input key material.
     *
     * The info string should be agreed upon beforehand, both parties need to
     * use the same info string.
     *
     * The number of bytes we can generate is limited, we can generate up to
     * 32 * 255 bytes. This function will return an error if the given count is
     * larger than the limit.
     */
    fun `bytesRaw`(`info`: kotlin.String, `count`: kotlin.UInt): kotlin.ByteArray
    
    /**
     * Calculate a MAC for the given input using the info string as additional data.
     *
     * This should be used to calculate a MAC of the ed25519 identity key of an Account.
     * The MAC is returned as a base64 encoded string.
     */
    fun `calculateMac`(`input`: kotlin.String, `info`: kotlin.String): Mac
    
    /**
     * Calculate a MAC for the given input using the info string as additional
     * data, the MAC is returned as an invalid base64 encoded string.
     *
     * **Warning**: This method should never be used unless you require libolm
     * compatibility. Libolm used to incorrectly encode their MAC because the
     * input buffer was reused as the output buffer.
     */
    fun `calculateMacInvalidBase64`(`input`: kotlin.String, `info`: kotlin.String): kotlin.String
    
    /**
     * Get the public key that was created by us, that was used to establish
     * the shared secret.
     */
    fun `ourPublicKey`(): Curve25519PublicKey
    
    /**
     * Get the public key that was created by the other party, that was used to
     * establish the shared secret.
     */
    fun `theirPublicKey`(): Curve25519PublicKey
    
    /**
     * Verify a MAC that was previously created using the calculate_mac method.
     *
     * Users should calculate a MAC and send it to the other side, they should
     * then verify each other's MAC using this method.
     */
    fun `verifyMac`(`input`: kotlin.String, `info`: kotlin.String, `tag`: Mac)
    
    companion object
}

/**
 * A struct representing a short auth string verification object where the
 * shared secret has been established.
 */
open class EstablishedSas: Disposable, AutoCloseable, EstablishedSasInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_establishedsas(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_establishedsas(handle, status)
        }
    }

    
    /**
     * Generate SasBytes using HKDF with the shared secret as the input key material.
     *
     * The info string should be agreed upon beforehand, both parties need to
     * use the same info string.
     */override fun `bytes`(`info`: kotlin.String): SasBytes {
            return FfiConverterTypeSasBytes.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_establishedsas_bytes(
        it, FfiConverterString.lower(`info`),_status)
}
    }
    )
    }
    

    
    /**
     * Generate the given number of bytes using HKDF with the shared secret
     * as the input key material.
     *
     * The info string should be agreed upon beforehand, both parties need to
     * use the same info string.
     *
     * The number of bytes we can generate is limited, we can generate up to
     * 32 * 255 bytes. This function will return an error if the given count is
     * larger than the limit.
     */
    @Throws(VodozemacException::class)override fun `bytesRaw`(`info`: kotlin.String, `count`: kotlin.UInt): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_establishedsas_bytes_raw(
        it, FfiConverterString.lower(`info`),FfiConverterUInt.lower(`count`),_status)
}
    }
    )
    }
    

    
    /**
     * Calculate a MAC for the given input using the info string as additional data.
     *
     * This should be used to calculate a MAC of the ed25519 identity key of an Account.
     * The MAC is returned as a base64 encoded string.
     */override fun `calculateMac`(`input`: kotlin.String, `info`: kotlin.String): Mac {
            return FfiConverterTypeMac.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_establishedsas_calculate_mac(
        it, FfiConverterString.lower(`input`),FfiConverterString.lower(`info`),_status)
}
    }
    )
    }
    

    
    /**
     * Calculate a MAC for the given input using the info string as additional
     * data, the MAC is returned as an invalid base64 encoded string.
     *
     * **Warning**: This method should never be used unless you require libolm
     * compatibility. Libolm used to incorrectly encode their MAC because the
     * input buffer was reused as the output buffer.
     */override fun `calculateMacInvalidBase64`(`input`: kotlin.String, `info`: kotlin.String): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_establishedsas_calculate_mac_invalid_base64(
        it, FfiConverterString.lower(`input`),FfiConverterString.lower(`info`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the public key that was created by us, that was used to establish
     * the shared secret.
     */override fun `ourPublicKey`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_establishedsas_our_public_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the public key that was created by the other party, that was used to
     * establish the shared secret.
     */override fun `theirPublicKey`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_establishedsas_their_public_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Verify a MAC that was previously created using the calculate_mac method.
     *
     * Users should calculate a MAC and send it to the other side, they should
     * then verify each other's MAC using this method.
     */
    @Throws(VodozemacException::class)override fun `verifyMac`(`input`: kotlin.String, `info`: kotlin.String, `tag`: Mac)
        = 
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_establishedsas_verify_mac(
        it, FfiConverterString.lower(`input`),FfiConverterString.lower(`info`),FfiConverterTypeMac.lower(`tag`),_status)
}
    }
    
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeEstablishedSas: FfiConverter<EstablishedSas, Long> {
    override fun lower(value: EstablishedSas): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): EstablishedSas {
        return EstablishedSas(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): EstablishedSas {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: EstablishedSas) = 8UL

    override fun write(value: EstablishedSas, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * An exported session key that can be used to create an InboundGroupSession
 *
 * This is used to share session keys between clients for group messaging
 */
public interface ExportedSessionKeyInterface {
    
    /**
     * Convert the exported session key to a base64 string
     */
    fun `toBase64`(): kotlin.String
    
    /**
     * Convert the exported session key to bytes
     */
    fun `toBytes`(): kotlin.ByteArray
    
    companion object
}

/**
 * An exported session key that can be used to create an InboundGroupSession
 *
 * This is used to share session keys between clients for group messaging
 */
open class ExportedSessionKey: Disposable, AutoCloseable, ExportedSessionKeyInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_exportedsessionkey(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_exportedsessionkey(handle, status)
        }
    }

    
    /**
     * Convert the exported session key to a base64 string
     */override fun `toBase64`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_exportedsessionkey_to_base64(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Convert the exported session key to bytes
     */override fun `toBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_exportedsessionkey_to_bytes(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create an ExportedSessionKey from a base64 string
     */
    @Throws(VodozemacException::class) fun `fromBase64`(`input`: kotlin.String): ExportedSessionKey {
            return FfiConverterTypeExportedSessionKey.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_exportedsessionkey_from_base64(
        FfiConverterString.lower(`input`),_status)
}
    )
    }
    

        
    /**
     * Create an ExportedSessionKey from bytes
     */
    @Throws(VodozemacException::class) fun `fromBytes`(`bytes`: kotlin.ByteArray): ExportedSessionKey {
            return FfiConverterTypeExportedSessionKey.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_exportedsessionkey_from_bytes(
        FfiConverterByteArray.lower(`bytes`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeExportedSessionKey: FfiConverter<ExportedSessionKey, Long> {
    override fun lower(value: ExportedSessionKey): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): ExportedSessionKey {
        return ExportedSessionKey(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): ExportedSessionKey {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: ExportedSessionKey) = 8UL

    override fun write(value: ExportedSessionKey, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * A Megolm group session for sending encrypted messages
 *
 * Represents a single sending participant in an encrypted group communication context
 */
public interface GroupSessionInterface {
    
    /**
     * Encrypt a plaintext message
     */
    fun `encrypt`(`plaintext`: kotlin.ByteArray): MegolmMessage
    
    /**
     * Get the current message index
     */
    fun `messageIndex`(): kotlin.UInt
    
    /**
     * Create a pickle from this group session
     */
    fun `pickle`(): GroupSessionPickle
    
    /**
     * Get the session ID
     */
    fun `sessionId`(): kotlin.String
    
    /**
     * Get the session key that can be shared with other participants
     */
    fun `sessionKey`(): SessionKey
    
    companion object
}

/**
 * A Megolm group session for sending encrypted messages
 *
 * Represents a single sending participant in an encrypted group communication context
 */
open class GroupSession: Disposable, AutoCloseable, GroupSessionInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    /**
     * Create a new group session with the default configuration (Version 2)
     */
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_groupsession_new(
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_groupsession(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_groupsession(handle, status)
        }
    }

    
    /**
     * Encrypt a plaintext message
     */override fun `encrypt`(`plaintext`: kotlin.ByteArray): MegolmMessage {
            return FfiConverterTypeMegolmMessage.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_groupsession_encrypt(
        it, FfiConverterByteArray.lower(`plaintext`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the current message index
     */override fun `messageIndex`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_groupsession_message_index(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Create a pickle from this group session
     */override fun `pickle`(): GroupSessionPickle {
            return FfiConverterTypeGroupSessionPickle.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_groupsession_pickle(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the session ID
     */override fun `sessionId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_groupsession_session_id(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the session key that can be shared with other participants
     */override fun `sessionKey`(): SessionKey {
            return FfiConverterTypeSessionKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_groupsession_session_key(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create a group session from a pickle
     */
    @Throws(VodozemacException::class) fun `fromPickle`(`pickle`: GroupSessionPickle): GroupSession {
            return FfiConverterTypeGroupSession.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_groupsession_from_pickle(
        FfiConverterTypeGroupSessionPickle.lower(`pickle`),_status)
}
    )
    }
    

        
    /**
     * Create a new group session with a specific configuration
     */ fun `withConfig`(`config`: MegolmSessionConfig): GroupSession {
            return FfiConverterTypeGroupSession.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_groupsession_with_config(
        FfiConverterTypeMegolmSessionConfig.lower(`config`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeGroupSession: FfiConverter<GroupSession, Long> {
    override fun lower(value: GroupSession): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): GroupSession {
        return GroupSession(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): GroupSession {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: GroupSession) = 8UL

    override fun write(value: GroupSession, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * A pickled group session that can be stored and later restored
 */
public interface GroupSessionPickleInterface {
    
    /**
     * Create an encrypted pickle from this group session pickle
     *
     * Note: This consumes the pickle as the encryption method takes ownership
     */
    fun `encrypt`(`pickleKey`: kotlin.ByteArray): kotlin.String
    
    companion object
}

/**
 * A pickled group session that can be stored and later restored
 */
open class GroupSessionPickle: Disposable, AutoCloseable, GroupSessionPickleInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_groupsessionpickle(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_groupsessionpickle(handle, status)
        }
    }

    
    /**
     * Create an encrypted pickle from this group session pickle
     *
     * Note: This consumes the pickle as the encryption method takes ownership
     */
    @Throws(VodozemacException::class)override fun `encrypt`(`pickleKey`: kotlin.ByteArray): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_groupsessionpickle_encrypt(
        it, FfiConverterByteArray.lower(`pickleKey`),_status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create a group session pickle by decrypting an encrypted pickle
     */
    @Throws(VodozemacException::class) fun `fromEncrypted`(`ciphertext`: kotlin.String, `pickleKey`: kotlin.ByteArray): GroupSessionPickle {
            return FfiConverterTypeGroupSessionPickle.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_groupsessionpickle_from_encrypted(
        FfiConverterString.lower(`ciphertext`),FfiConverterByteArray.lower(`pickleKey`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeGroupSessionPickle: FfiConverter<GroupSessionPickle, Long> {
    override fun lower(value: GroupSessionPickle): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): GroupSessionPickle {
        return GroupSessionPickle(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): GroupSessionPickle {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: GroupSessionPickle) = 8UL

    override fun write(value: GroupSessionPickle, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * The two main identity keys of an Account.
 */
public interface IdentityKeysInterface {
    
    /**
     * The Curve25519 identity key, used for Diffie-Hellman operations.
     */
    fun `curve25519`(): Curve25519PublicKey
    
    /**
     * The Ed25519 identity key, used for signing.
     */
    fun `ed25519`(): Ed25519PublicKey
    
    companion object
}

/**
 * The two main identity keys of an Account.
 */
open class IdentityKeys: Disposable, AutoCloseable, IdentityKeysInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_identitykeys(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_identitykeys(handle, status)
        }
    }

    
    /**
     * The Curve25519 identity key, used for Diffie-Hellman operations.
     */override fun `curve25519`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_identitykeys_curve25519(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The Ed25519 identity key, used for signing.
     */override fun `ed25519`(): Ed25519PublicKey {
            return FfiConverterTypeEd25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_identitykeys_ed25519(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeIdentityKeys: FfiConverter<IdentityKeys, Long> {
    override fun lower(value: IdentityKeys): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): IdentityKeys {
        return IdentityKeys(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): IdentityKeys {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: IdentityKeys) = 8UL

    override fun write(value: IdentityKeys, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * The result of an inbound ECIES channel establishment.
 */
public interface InboundCreationResultInterface {
    
    /**
     * Get the established ECIES channel.
     */
    fun `ecies`(): EstablishedEcies
    
    /**
     * Get the plaintext of the initial message.
     */
    fun `message`(): kotlin.ByteArray
    
    companion object
}

/**
 * The result of an inbound ECIES channel establishment.
 */
open class InboundCreationResult: Disposable, AutoCloseable, InboundCreationResultInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_inboundcreationresult(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_inboundcreationresult(handle, status)
        }
    }

    
    /**
     * Get the established ECIES channel.
     */override fun `ecies`(): EstablishedEcies {
            return FfiConverterTypeEstablishedEcies.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_inboundcreationresult_ecies(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the plaintext of the initial message.
     */override fun `message`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_inboundcreationresult_message(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeInboundCreationResult: FfiConverter<InboundCreationResult, Long> {
    override fun lower(value: InboundCreationResult): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): InboundCreationResult {
        return InboundCreationResult(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): InboundCreationResult {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: InboundCreationResult) = 8UL

    override fun write(value: InboundCreationResult, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * A Megolm inbound group session for receiving encrypted messages
 *
 * Represents a single receiving participant in an encrypted group communication
 */
public interface InboundGroupSessionInterface {
    
    /**
     * Compare sessions to determine their relative position in the ratchet
     */
    fun `compare`(`other`: InboundGroupSession): SessionOrdering
    
    /**
     * Decrypt a megolm message
     */
    fun `decrypt`(`message`: MegolmMessage): DecryptedMessage
    
    /**
     * Export the session at a specific message index
     */
    fun `exportAt`(`messageIndex`: kotlin.UInt): ExportedSessionKey?
    
    /**
     * Get the first known message index
     */
    fun `firstKnownIndex`(): kotlin.UInt
    
    /**
     * Create a pickle from this inbound group session
     */
    fun `pickle`(): InboundGroupSessionPickle
    
    /**
     * Get the session ID
     */
    fun `sessionId`(): kotlin.String
    
    companion object
}

/**
 * A Megolm inbound group session for receiving encrypted messages
 *
 * Represents a single receiving participant in an encrypted group communication
 */
open class InboundGroupSession: Disposable, AutoCloseable, InboundGroupSessionInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    /**
     * Create an inbound group session from a session key
     */
    constructor(`sessionKey`: SessionKey, `config`: MegolmSessionConfig) :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_inboundgroupsession_new(
        FfiConverterTypeSessionKey.lower(`sessionKey`),FfiConverterTypeMegolmSessionConfig.lower(`config`),_status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_inboundgroupsession(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_inboundgroupsession(handle, status)
        }
    }

    
    /**
     * Compare sessions to determine their relative position in the ratchet
     */override fun `compare`(`other`: InboundGroupSession): SessionOrdering {
            return FfiConverterTypeSessionOrdering.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_inboundgroupsession_compare(
        it, FfiConverterTypeInboundGroupSession.lower(`other`),_status)
}
    }
    )
    }
    

    
    /**
     * Decrypt a megolm message
     */
    @Throws(VodozemacException::class)override fun `decrypt`(`message`: MegolmMessage): DecryptedMessage {
            return FfiConverterTypeDecryptedMessage.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_inboundgroupsession_decrypt(
        it, FfiConverterTypeMegolmMessage.lower(`message`),_status)
}
    }
    )
    }
    

    
    /**
     * Export the session at a specific message index
     */override fun `exportAt`(`messageIndex`: kotlin.UInt): ExportedSessionKey? {
            return FfiConverterOptionalTypeExportedSessionKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_inboundgroupsession_export_at(
        it, FfiConverterUInt.lower(`messageIndex`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the first known message index
     */override fun `firstKnownIndex`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_inboundgroupsession_first_known_index(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Create a pickle from this inbound group session
     */override fun `pickle`(): InboundGroupSessionPickle {
            return FfiConverterTypeInboundGroupSessionPickle.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_inboundgroupsession_pickle(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the session ID
     */override fun `sessionId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_inboundgroupsession_session_id(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create an inbound group session from a pickle
     */
    @Throws(VodozemacException::class) fun `fromPickle`(`pickle`: InboundGroupSessionPickle): InboundGroupSession {
            return FfiConverterTypeInboundGroupSession.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_inboundgroupsession_from_pickle(
        FfiConverterTypeInboundGroupSessionPickle.lower(`pickle`),_status)
}
    )
    }
    

        
    /**
     * Import an inbound group session from an exported session key
     */ fun `import`(`exportedKey`: ExportedSessionKey, `config`: MegolmSessionConfig): InboundGroupSession {
            return FfiConverterTypeInboundGroupSession.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_inboundgroupsession_import(
        FfiConverterTypeExportedSessionKey.lower(`exportedKey`),FfiConverterTypeMegolmSessionConfig.lower(`config`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeInboundGroupSession: FfiConverter<InboundGroupSession, Long> {
    override fun lower(value: InboundGroupSession): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): InboundGroupSession {
        return InboundGroupSession(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): InboundGroupSession {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: InboundGroupSession) = 8UL

    override fun write(value: InboundGroupSession, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * A pickled inbound group session that can be stored and later restored
 */
public interface InboundGroupSessionPickleInterface {
    
    /**
     * Create an encrypted pickle from this inbound group session pickle
     *
     * Note: This consumes the pickle as the encryption method takes ownership
     */
    fun `encrypt`(`pickleKey`: kotlin.ByteArray): kotlin.String
    
    companion object
}

/**
 * A pickled inbound group session that can be stored and later restored
 */
open class InboundGroupSessionPickle: Disposable, AutoCloseable, InboundGroupSessionPickleInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_inboundgroupsessionpickle(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_inboundgroupsessionpickle(handle, status)
        }
    }

    
    /**
     * Create an encrypted pickle from this inbound group session pickle
     *
     * Note: This consumes the pickle as the encryption method takes ownership
     */
    @Throws(VodozemacException::class)override fun `encrypt`(`pickleKey`: kotlin.ByteArray): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_inboundgroupsessionpickle_encrypt(
        it, FfiConverterByteArray.lower(`pickleKey`),_status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create an inbound group session pickle by decrypting an encrypted pickle
     */
    @Throws(VodozemacException::class) fun `fromEncrypted`(`ciphertext`: kotlin.String, `pickleKey`: kotlin.ByteArray): InboundGroupSessionPickle {
            return FfiConverterTypeInboundGroupSessionPickle.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_inboundgroupsessionpickle_from_encrypted(
        FfiConverterString.lower(`ciphertext`),FfiConverterByteArray.lower(`pickleKey`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeInboundGroupSessionPickle: FfiConverter<InboundGroupSessionPickle, Long> {
    override fun lower(value: InboundGroupSessionPickle): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): InboundGroupSessionPickle {
        return InboundGroupSessionPickle(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): InboundGroupSessionPickle {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: InboundGroupSessionPickle) = 8UL

    override fun write(value: InboundGroupSessionPickle, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * The initial message, sent by the ECIES channel establisher.
 * This message embeds the public key of the message creator allowing the other
 * side to establish a channel using this message.
 */
public interface InitialMessageInterface {
    
    /**
     * Get the ciphertext of the initial message.
     */
    fun `ciphertext`(): kotlin.ByteArray
    
    /**
     * Encode the message as a string.
     * The string will contain the base64-encoded Curve25519 public key and the
     * ciphertext of the message separated by a `|`.
     */
    fun `encode`(): kotlin.String
    
    /**
     * Get the ephemeral public key that was used to establish the ECIES channel.
     */
    fun `publicKey`(): Curve25519PublicKey
    
    companion object
}

/**
 * The initial message, sent by the ECIES channel establisher.
 * This message embeds the public key of the message creator allowing the other
 * side to establish a channel using this message.
 */
open class InitialMessage: Disposable, AutoCloseable, InitialMessageInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_initialmessage(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_initialmessage(handle, status)
        }
    }

    
    /**
     * Get the ciphertext of the initial message.
     */override fun `ciphertext`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_initialmessage_ciphertext(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Encode the message as a string.
     * The string will contain the base64-encoded Curve25519 public key and the
     * ciphertext of the message separated by a `|`.
     */override fun `encode`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_initialmessage_encode(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the ephemeral public key that was used to establish the ECIES channel.
     */override fun `publicKey`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_initialmessage_public_key(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Attempt to decode a string into an InitialMessage.
     */
    @Throws(VodozemacException::class) fun `decode`(`message`: kotlin.String): InitialMessage {
            return FfiConverterTypeInitialMessage.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_initialmessage_decode(
        FfiConverterString.lower(`message`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeInitialMessage: FfiConverter<InitialMessage, Long> {
    override fun lower(value: InitialMessage): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): InitialMessage {
        return InitialMessage(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): InitialMessage {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: InitialMessage) = 8UL

    override fun write(value: InitialMessage, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * Error type for the case when we try to generate too many SAS bytes.
 */
public interface InvalidCountInterface {
    
    /**
     * Get the error message.
     */
    fun `message`(): kotlin.String
    
    companion object
}

/**
 * Error type for the case when we try to generate too many SAS bytes.
 */
open class InvalidCount: Disposable, AutoCloseable, InvalidCountInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_invalidcount(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_invalidcount(handle, status)
        }
    }

    
    /**
     * Get the error message.
     */override fun `message`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_invalidcount_message(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeInvalidCount: FfiConverter<InvalidCount, Long> {
    override fun lower(value: InvalidCount): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): InvalidCount {
        return InvalidCount(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): InvalidCount {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: InvalidCount) = 8UL

    override fun write(value: InvalidCount, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * Key ID wrapper for UniFFI
 *
 * Pattern: Simple object with constructor and method
 */
public interface KeyIdInterface {
    
    /**
     * Convert the KeyId to a base64 string
     *
     * Pattern: Simple method returning primitive type
     */
    fun `toBase64`(): kotlin.String
    
    companion object
}

/**
 * Key ID wrapper for UniFFI
 *
 * Pattern: Simple object with constructor and method
 */
open class KeyId: Disposable, AutoCloseable, KeyIdInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_keyid(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_keyid(handle, status)
        }
    }

    
    /**
     * Convert the KeyId to a base64 string
     *
     * Pattern: Simple method returning primitive type
     */override fun `toBase64`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_keyid_to_base64(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create a KeyId from a u64 value
     *
     * Pattern: Simple constructor returning Arc<Self>
     */ fun `fromU64`(`value`: kotlin.ULong): KeyId {
            return FfiConverterTypeKeyId.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_keyid_from_u64(
        FfiConverterULong.lower(`value`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeKeyId: FfiConverter<KeyId, Long> {
    override fun lower(value: KeyId): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): KeyId {
        return KeyId(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): KeyId {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: KeyId) = 8UL

    override fun write(value: KeyId, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * The output type for the SAS MAC calculation.
 */
public interface MacInterface {
    
    /**
     * Get the raw bytes of the MAC.
     */
    fun `asBytes`(): kotlin.ByteArray
    
    /**
     * Get the MAC as base64-encoded string.
     */
    fun `toBase64`(): kotlin.String
    
    companion object
}

/**
 * The output type for the SAS MAC calculation.
 */
open class Mac: Disposable, AutoCloseable, MacInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_mac(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_mac(handle, status)
        }
    }

    
    /**
     * Get the raw bytes of the MAC.
     */override fun `asBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_mac_as_bytes(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the MAC as base64-encoded string.
     */override fun `toBase64`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_mac_to_base64(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Construct a MAC object from a base64-encoded string.
     */
    @Throws(VodozemacException::class) fun `fromBase64`(`mac`: kotlin.String): Mac {
            return FfiConverterTypeMac.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_mac_from_base64(
        FfiConverterString.lower(`mac`),_status)
}
    )
    }
    

        
    /**
     * Construct a MAC object from raw bytes.
     */ fun `fromSlice`(`bytes`: kotlin.ByteArray): Mac {
            return FfiConverterTypeMac.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_mac_from_slice(
        FfiConverterByteArray.lower(`bytes`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeMac: FfiConverter<Mac, Long> {
    override fun lower(value: Mac): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Mac {
        return Mac(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Mac {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Mac) = 8UL

    override fun write(value: Mac, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * An encrypted Megolm message
 *
 * Contains the ciphertext, signature, and metadata for a group message
 */
public interface MegolmMessageInterface {
    
    /**
     * Get the ciphertext
     */
    fun `ciphertext`(): kotlin.ByteArray
    
    /**
     * Get the message index
     */
    fun `messageIndex`(): kotlin.UInt
    
    /**
     * Convert the message to a base64 string
     */
    fun `toBase64`(): kotlin.String
    
    /**
     * Convert the message to bytes
     */
    fun `toBytes`(): kotlin.ByteArray
    
    companion object
}

/**
 * An encrypted Megolm message
 *
 * Contains the ciphertext, signature, and metadata for a group message
 */
open class MegolmMessage: Disposable, AutoCloseable, MegolmMessageInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_megolmmessage(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_megolmmessage(handle, status)
        }
    }

    
    /**
     * Get the ciphertext
     */override fun `ciphertext`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_megolmmessage_ciphertext(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the message index
     */override fun `messageIndex`(): kotlin.UInt {
            return FfiConverterUInt.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_megolmmessage_message_index(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Convert the message to a base64 string
     */override fun `toBase64`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_megolmmessage_to_base64(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Convert the message to bytes
     */override fun `toBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_megolmmessage_to_bytes(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create a MegolmMessage from a base64 string
     */
    @Throws(VodozemacException::class) fun `fromBase64`(`input`: kotlin.String): MegolmMessage {
            return FfiConverterTypeMegolmMessage.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_megolmmessage_from_base64(
        FfiConverterString.lower(`input`),_status)
}
    )
    }
    

        
    /**
     * Create a MegolmMessage from bytes
     */
    @Throws(VodozemacException::class) fun `fromBytes`(`bytes`: kotlin.ByteArray): MegolmMessage {
            return FfiConverterTypeMegolmMessage.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_megolmmessage_from_bytes(
        FfiConverterByteArray.lower(`bytes`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeMegolmMessage: FfiConverter<MegolmMessage, Long> {
    override fun lower(value: MegolmMessage): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): MegolmMessage {
        return MegolmMessage(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): MegolmMessage {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: MegolmMessage) = 8UL

    override fun write(value: MegolmMessage, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * Configuration options for Megolm sessions
 *
 * This determines the version and encryption parameters used for the session
 */
public interface MegolmSessionConfigInterface {
    
    companion object
}

/**
 * Configuration options for Megolm sessions
 *
 * This determines the version and encryption parameters used for the session
 */
open class MegolmSessionConfig: Disposable, AutoCloseable, MegolmSessionConfigInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_megolmsessionconfig(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_megolmsessionconfig(handle, status)
        }
    }

    

    
    companion object {
        
    /**
     * Create a Version 1 session configuration
     *
     * Version 1 uses truncated MAC for better compatibility with older clients
     */ fun `version1`(): MegolmSessionConfig {
            return FfiConverterTypeMegolmSessionConfig.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_megolmsessionconfig_version_1(
        _status)
}
    )
    }
    

        
    /**
     * Create a Version 2 session configuration
     *
     * Version 2 uses full MAC for better security
     */ fun `version2`(): MegolmSessionConfig {
            return FfiConverterTypeMegolmSessionConfig.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_megolmsessionconfig_version_2(
        _status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeMegolmSessionConfig: FfiConverter<MegolmSessionConfig, Long> {
    override fun lower(value: MegolmSessionConfig): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): MegolmSessionConfig {
        return MegolmSessionConfig(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): MegolmSessionConfig {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: MegolmSessionConfig) = 8UL

    override fun write(value: MegolmSessionConfig, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * An encrypted message an EstablishedEcies channel has sent.
 */
public interface MessageInterface {
    
    /**
     * Get the ciphertext bytes.
     */
    fun `ciphertext`(): kotlin.ByteArray
    
    /**
     * Encode the message as a string.
     * The ciphertext bytes will be encoded using unpadded base64.
     */
    fun `encode`(): kotlin.String
    
    companion object
}

/**
 * An encrypted message an EstablishedEcies channel has sent.
 */
open class Message: Disposable, AutoCloseable, MessageInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_message(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_message(handle, status)
        }
    }

    
    /**
     * Get the ciphertext bytes.
     */override fun `ciphertext`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_message_ciphertext(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Encode the message as a string.
     * The ciphertext bytes will be encoded using unpadded base64.
     */override fun `encode`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_message_encode(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Attempt to decode a base64 string into a Message.
     */
    @Throws(VodozemacException::class) fun `decode`(`message`: kotlin.String): Message {
            return FfiConverterTypeMessage.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_message_decode(
        FfiConverterString.lower(`message`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeMessage: FfiConverter<Message, Long> {
    override fun lower(value: Message): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Message {
        return Message(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Message {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Message) = 8UL

    override fun write(value: Message, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * The result when creating an inbound Olm session.
 */
public interface OlmInboundCreationResultInterface {
    
    /**
     * Get the decrypted plaintext of the message.
     */
    fun `plaintext`(): kotlin.ByteArray
    
    /**
     * Get the created session.
     */
    fun `session`(): Session
    
    companion object
}

/**
 * The result when creating an inbound Olm session.
 */
open class OlmInboundCreationResult: Disposable, AutoCloseable, OlmInboundCreationResultInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_olminboundcreationresult(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_olminboundcreationresult(handle, status)
        }
    }

    
    /**
     * Get the decrypted plaintext of the message.
     */override fun `plaintext`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_olminboundcreationresult_plaintext(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the created session.
     */override fun `session`(): Session {
            return FfiConverterTypeSession.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_olminboundcreationresult_session(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeOlmInboundCreationResult: FfiConverter<OlmInboundCreationResult, Long> {
    override fun lower(value: OlmInboundCreationResult): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): OlmInboundCreationResult {
        return OlmInboundCreationResult(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): OlmInboundCreationResult {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: OlmInboundCreationResult) = 8UL

    override fun write(value: OlmInboundCreationResult, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * An encrypted Olm message.
 */
public interface OlmMessageInterface {
    
    /**
     * Get the type of this message.
     */
    fun `messageType`(): MessageType
    
    /**
     * Encode the OlmMessage as a base64 string.
     */
    fun `toBase64`(): kotlin.String
    
    companion object
}

/**
 * An encrypted Olm message.
 */
open class OlmMessage: Disposable, AutoCloseable, OlmMessageInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_olmmessage(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_olmmessage(handle, status)
        }
    }

    
    /**
     * Get the type of this message.
     */override fun `messageType`(): MessageType {
            return FfiConverterTypeMessageType.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_olmmessage_message_type(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Encode the OlmMessage as a base64 string.
     */override fun `toBase64`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_olmmessage_to_base64(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Try to decode the given string as an OlmMessage.
     */
    @Throws(VodozemacException::class) fun `fromBase64`(`message`: kotlin.String): OlmMessage {
            return FfiConverterTypeOlmMessage.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_olmmessage_from_base64(
        FfiConverterString.lower(`message`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeOlmMessage: FfiConverter<OlmMessage, Long> {
    override fun lower(value: OlmMessage): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): OlmMessage {
        return OlmMessage(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): OlmMessage {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: OlmMessage) = 8UL

    override fun write(value: OlmMessage, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * An encrypted Olm message.
 */
public interface OlmNormalMessageInterface {
    
    /**
     * The index of the chain that was used when the message was encrypted.
     */
    fun `chainIndex`(): kotlin.ULong
    
    /**
     * The actual ciphertext of the message.
     */
    fun `ciphertext`(): kotlin.ByteArray
    
    /**
     * Has the MAC been truncated in this Olm message.
     */
    fun `macTruncated`(): kotlin.Boolean
    
    /**
     * The ratchet key that was used to encrypt this message.
     */
    fun `ratchetKey`(): Curve25519PublicKey
    
    /**
     * Encode the Message as a string.
     */
    fun `toBase64`(): kotlin.String
    
    /**
     * Encode the Message as an array of bytes.
     */
    fun `toBytes`(): kotlin.ByteArray
    
    /**
     * The version of the Olm message.
     */
    fun `version`(): kotlin.UByte
    
    companion object
}

/**
 * An encrypted Olm message.
 */
open class OlmNormalMessage: Disposable, AutoCloseable, OlmNormalMessageInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_olmnormalmessage(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_olmnormalmessage(handle, status)
        }
    }

    
    /**
     * The index of the chain that was used when the message was encrypted.
     */override fun `chainIndex`(): kotlin.ULong {
            return FfiConverterULong.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_olmnormalmessage_chain_index(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The actual ciphertext of the message.
     */override fun `ciphertext`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_olmnormalmessage_ciphertext(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Has the MAC been truncated in this Olm message.
     */override fun `macTruncated`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_olmnormalmessage_mac_truncated(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The ratchet key that was used to encrypt this message.
     */override fun `ratchetKey`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_olmnormalmessage_ratchet_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Encode the Message as a string.
     */override fun `toBase64`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_olmnormalmessage_to_base64(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Encode the Message as an array of bytes.
     */override fun `toBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_olmnormalmessage_to_bytes(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The version of the Olm message.
     */override fun `version`(): kotlin.UByte {
            return FfiConverterUByte.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_olmnormalmessage_version(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Try to decode the given string as an Olm Message.
     */
    @Throws(VodozemacException::class) fun `fromBase64`(`message`: kotlin.String): OlmNormalMessage {
            return FfiConverterTypeOlmNormalMessage.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_olmnormalmessage_from_base64(
        FfiConverterString.lower(`message`),_status)
}
    )
    }
    

        
    /**
     * Try to decode the given byte slice as an Olm Message.
     */
    @Throws(VodozemacException::class) fun `fromBytes`(`bytes`: kotlin.ByteArray): OlmNormalMessage {
            return FfiConverterTypeOlmNormalMessage.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_olmnormalmessage_from_bytes(
        FfiConverterByteArray.lower(`bytes`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeOlmNormalMessage: FfiConverter<OlmNormalMessage, Long> {
    override fun lower(value: OlmNormalMessage): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): OlmNormalMessage {
        return OlmNormalMessage(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): OlmNormalMessage {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: OlmNormalMessage) = 8UL

    override fun write(value: OlmNormalMessage, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * Result of generating one-time keys.
 */
public interface OneTimeKeyGenerationResultInterface {
    
    /**
     * Get the discarded keys.
     */
    fun `discarded`(): List<Curve25519PublicKey>
    
    /**
     * Get the generated keys.
     */
    fun `generated`(): List<Curve25519PublicKey>
    
    companion object
}

/**
 * Result of generating one-time keys.
 */
open class OneTimeKeyGenerationResult: Disposable, AutoCloseable, OneTimeKeyGenerationResultInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_onetimekeygenerationresult(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_onetimekeygenerationresult(handle, status)
        }
    }

    
    /**
     * Get the discarded keys.
     */override fun `discarded`(): List<Curve25519PublicKey> {
            return FfiConverterSequenceTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_onetimekeygenerationresult_discarded(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the generated keys.
     */override fun `generated`(): List<Curve25519PublicKey> {
            return FfiConverterSequenceTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_onetimekeygenerationresult_generated(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeOneTimeKeyGenerationResult: FfiConverter<OneTimeKeyGenerationResult, Long> {
    override fun lower(value: OneTimeKeyGenerationResult): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): OneTimeKeyGenerationResult {
        return OneTimeKeyGenerationResult(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): OneTimeKeyGenerationResult {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: OneTimeKeyGenerationResult) = 8UL

    override fun write(value: OneTimeKeyGenerationResult, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * A one-time key pair containing an ID and the key itself.
 */
public interface OneTimeKeyPairInterface {
    
    /**
     * Get the public key.
     */
    fun `key`(): Curve25519PublicKey
    
    /**
     * Get the key ID.
     */
    fun `keyId`(): KeyId
    
    companion object
}

/**
 * A one-time key pair containing an ID and the key itself.
 */
open class OneTimeKeyPair: Disposable, AutoCloseable, OneTimeKeyPairInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_onetimekeypair(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_onetimekeypair(handle, status)
        }
    }

    
    /**
     * Get the public key.
     */override fun `key`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_onetimekeypair_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the key ID.
     */override fun `keyId`(): KeyId {
            return FfiConverterTypeKeyId.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_onetimekeypair_key_id(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeOneTimeKeyPair: FfiConverter<OneTimeKeyPair, Long> {
    override fun lower(value: OneTimeKeyPair): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): OneTimeKeyPair {
        return OneTimeKeyPair(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): OneTimeKeyPair {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: OneTimeKeyPair) = 8UL

    override fun write(value: OneTimeKeyPair, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * The result of an outbound ECIES channel establishment.
 */
public interface OutboundCreationResultInterface {
    
    /**
     * Get the established ECIES channel.
     */
    fun `ecies`(): EstablishedEcies
    
    /**
     * Get the initial message.
     */
    fun `message`(): InitialMessage
    
    companion object
}

/**
 * The result of an outbound ECIES channel establishment.
 */
open class OutboundCreationResult: Disposable, AutoCloseable, OutboundCreationResultInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_outboundcreationresult(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_outboundcreationresult(handle, status)
        }
    }

    
    /**
     * Get the established ECIES channel.
     */override fun `ecies`(): EstablishedEcies {
            return FfiConverterTypeEstablishedEcies.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_outboundcreationresult_ecies(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the initial message.
     */override fun `message`(): InitialMessage {
            return FfiConverterTypeInitialMessage.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_outboundcreationresult_message(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeOutboundCreationResult: FfiConverter<OutboundCreationResult, Long> {
    override fun lower(value: OutboundCreationResult): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): OutboundCreationResult {
        return OutboundCreationResult(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): OutboundCreationResult {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: OutboundCreationResult) = 8UL

    override fun write(value: OutboundCreationResult, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * An encrypted Olm pre-key message.
 */
public interface PreKeyMessageInterface {
    
    /**
     * The base key that was created just in time by the sender of the message.
     */
    fun `baseKey`(): Curve25519PublicKey
    
    /**
     * The long term identity key of the sender of the message.
     */
    fun `identityKey`(): Curve25519PublicKey
    
    /**
     * The actual message that contains the ciphertext.
     */
    fun `message`(): OlmNormalMessage
    
    /**
     * The one-time key that was used by the receiver of the message.
     */
    fun `oneTimeKey`(): Curve25519PublicKey
    
    /**
     * Returns the globally unique session ID, in base64-encoded form.
     */
    fun `sessionId`(): kotlin.String
    
    /**
     * The collection of all keys required for establishing an Olm Session.
     */
    fun `sessionKeys`(): SessionKeys
    
    /**
     * Encode the PreKeyMessage as a string.
     */
    fun `toBase64`(): kotlin.String
    
    /**
     * Encode the PreKeyMessage as an array of bytes.
     */
    fun `toBytes`(): kotlin.ByteArray
    
    companion object
}

/**
 * An encrypted Olm pre-key message.
 */
open class PreKeyMessage: Disposable, AutoCloseable, PreKeyMessageInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_prekeymessage(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_prekeymessage(handle, status)
        }
    }

    
    /**
     * The base key that was created just in time by the sender of the message.
     */override fun `baseKey`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_prekeymessage_base_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The long term identity key of the sender of the message.
     */override fun `identityKey`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_prekeymessage_identity_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The actual message that contains the ciphertext.
     */override fun `message`(): OlmNormalMessage {
            return FfiConverterTypeOlmNormalMessage.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_prekeymessage_message(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The one-time key that was used by the receiver of the message.
     */override fun `oneTimeKey`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_prekeymessage_one_time_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns the globally unique session ID, in base64-encoded form.
     */override fun `sessionId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_prekeymessage_session_id(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The collection of all keys required for establishing an Olm Session.
     */override fun `sessionKeys`(): SessionKeys {
            return FfiConverterTypeSessionKeys.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_prekeymessage_session_keys(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Encode the PreKeyMessage as a string.
     */override fun `toBase64`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_prekeymessage_to_base64(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Encode the PreKeyMessage as an array of bytes.
     */override fun `toBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_prekeymessage_to_bytes(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Try to decode the given string as an Olm PreKeyMessage.
     */
    @Throws(VodozemacException::class) fun `fromBase64`(`message`: kotlin.String): PreKeyMessage {
            return FfiConverterTypePreKeyMessage.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_prekeymessage_from_base64(
        FfiConverterString.lower(`message`),_status)
}
    )
    }
    

        
    /**
     * Try to decode the given byte slice as an Olm PreKeyMessage.
     */
    @Throws(VodozemacException::class) fun `fromBytes`(`message`: kotlin.ByteArray): PreKeyMessage {
            return FfiConverterTypePreKeyMessage.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_prekeymessage_from_bytes(
        FfiConverterByteArray.lower(`message`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypePreKeyMessage: FfiConverter<PreKeyMessage, Long> {
    override fun lower(value: PreKeyMessage): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): PreKeyMessage {
        return PreKeyMessage(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): PreKeyMessage {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: PreKeyMessage) = 8UL

    override fun write(value: PreKeyMessage, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * The public part of a ratchet key pair.
 */
public interface RatchetPublicKeyInterface {
    
    /**
     * Convert the RatchetPublicKey to a base64 encoded string.
     */
    fun `toBase64`(): kotlin.String
    
    companion object
}

/**
 * The public part of a ratchet key pair.
 */
open class RatchetPublicKey: Disposable, AutoCloseable, RatchetPublicKeyInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_ratchetpublickey(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_ratchetpublickey(handle, status)
        }
    }

    
    /**
     * Convert the RatchetPublicKey to a base64 encoded string.
     */override fun `toBase64`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_ratchetpublickey_to_base64(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Try to create a RatchetPublicKey from the given base64 encoded string.
     */
    @Throws(VodozemacException::class) fun `fromBase64`(`key`: kotlin.String): RatchetPublicKey {
            return FfiConverterTypeRatchetPublicKey.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_ratchetpublickey_from_base64(
        FfiConverterString.lower(`key`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeRatchetPublicKey: FfiConverter<RatchetPublicKey, Long> {
    override fun lower(value: RatchetPublicKey): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): RatchetPublicKey {
        return RatchetPublicKey(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): RatchetPublicKey {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: RatchetPublicKey) = 8UL

    override fun write(value: RatchetPublicKey, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * A struct representing a short auth string verification object.
 */
public interface SasInterface {
    
    /**
     * Establish a SAS secret by performing a DH handshake with another public key.
     *
     * Returns an EstablishedSas object which can be used to generate SasBytes.
     */
    fun `diffieHellman`(`theirPublicKey`: Curve25519PublicKey): EstablishedSas
    
    /**
     * Establish a SAS secret by performing a DH handshake with another public key
     * in "raw", base64-encoded form.
     */
    fun `diffieHellmanWithRaw`(`otherPublicKey`: kotlin.String): EstablishedSas
    
    /**
     * Get the public key that can be used to establish a shared secret.
     */
    fun `publicKey`(): Curve25519PublicKey
    
    companion object
}

/**
 * A struct representing a short auth string verification object.
 */
open class Sas: Disposable, AutoCloseable, SasInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }
    /**
     * Create a new SAS verification object.
     */
    constructor() :
        this(UniffiWithHandle, 
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_sas_new(
        _status)
}
    )

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_sas(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_sas(handle, status)
        }
    }

    
    /**
     * Establish a SAS secret by performing a DH handshake with another public key.
     *
     * Returns an EstablishedSas object which can be used to generate SasBytes.
     */
    @Throws(VodozemacException::class)override fun `diffieHellman`(`theirPublicKey`: Curve25519PublicKey): EstablishedSas {
            return FfiConverterTypeEstablishedSas.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sas_diffie_hellman(
        it, FfiConverterTypeCurve25519PublicKey.lower(`theirPublicKey`),_status)
}
    }
    )
    }
    

    
    /**
     * Establish a SAS secret by performing a DH handshake with another public key
     * in "raw", base64-encoded form.
     */
    @Throws(VodozemacException::class)override fun `diffieHellmanWithRaw`(`otherPublicKey`: kotlin.String): EstablishedSas {
            return FfiConverterTypeEstablishedSas.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sas_diffie_hellman_with_raw(
        it, FfiConverterString.lower(`otherPublicKey`),_status)
}
    }
    )
    }
    

    
    /**
     * Get the public key that can be used to establish a shared secret.
     */
    @Throws(VodozemacException::class)override fun `publicKey`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sas_public_key(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeSas: FfiConverter<Sas, Long> {
    override fun lower(value: Sas): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Sas {
        return Sas(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Sas {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Sas) = 8UL

    override fun write(value: Sas, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * Bytes generated from a shared secret that can be used as the short auth string.
 */
public interface SasBytesInterface {
    
    /**
     * Get the raw bytes of the short auth string.
     */
    fun `asBytes`(): kotlin.ByteArray
    
    /**
     * Get the three decimal numbers that can be presented to users to perform
     * the key verification.
     */
    fun `decimals`(): List<kotlin.UShort>
    
    /**
     * Get the seven emoji indices that can be presented to users to perform
     * the key verification.
     *
     * The table that maps the index to an emoji can be found in the spec.
     */
    fun `emojiIndices`(): kotlin.ByteArray
    
    companion object
}

/**
 * Bytes generated from a shared secret that can be used as the short auth string.
 */
open class SasBytes: Disposable, AutoCloseable, SasBytesInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_sasbytes(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_sasbytes(handle, status)
        }
    }

    
    /**
     * Get the raw bytes of the short auth string.
     */override fun `asBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sasbytes_as_bytes(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the three decimal numbers that can be presented to users to perform
     * the key verification.
     */override fun `decimals`(): List<kotlin.UShort> {
            return FfiConverterSequenceUShort.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sasbytes_decimals(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the seven emoji indices that can be presented to users to perform
     * the key verification.
     *
     * The table that maps the index to an emoji can be found in the spec.
     */override fun `emojiIndices`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sasbytes_emoji_indices(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeSasBytes: FfiConverter<SasBytes, Long> {
    override fun lower(value: SasBytes): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): SasBytes {
        return SasBytes(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): SasBytes {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: SasBytes) = 8UL

    override fun write(value: SasBytes, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * An Olm session represents one end of an encrypted communication channel.
 */
public interface SessionInterface {
    
    /**
     * Try to decrypt an Olm message.
     */
    fun `decrypt`(`message`: OlmMessage): kotlin.ByteArray
    
    /**
     * Encrypt the plaintext and construct an OlmMessage.
     */
    fun `encrypt`(`plaintext`: kotlin.ByteArray): OlmMessage
    
    /**
     * Have we ever received and decrypted a message from the other side?
     */
    fun `hasReceivedMessage`(): kotlin.Boolean
    
    /**
     * Convert the session into a struct which implements serde::Serialize and serde::Deserialize.
     */
    fun `pickle`(): SessionPickle
    
    /**
     * Get the SessionConfig that this Session is configured to use.
     */
    fun `sessionConfig`(): SessionConfig
    
    /**
     * Returns the globally unique session ID, in base64-encoded form.
     */
    fun `sessionId`(): kotlin.String
    
    /**
     * Get the keys associated with this session.
     */
    fun `sessionKeys`(): SessionKeys
    
    companion object
}

/**
 * An Olm session represents one end of an encrypted communication channel.
 */
open class Session: Disposable, AutoCloseable, SessionInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_session(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_session(handle, status)
        }
    }

    
    /**
     * Try to decrypt an Olm message.
     */
    @Throws(VodozemacException::class)override fun `decrypt`(`message`: OlmMessage): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_session_decrypt(
        it, FfiConverterTypeOlmMessage.lower(`message`),_status)
}
    }
    )
    }
    

    
    /**
     * Encrypt the plaintext and construct an OlmMessage.
     */override fun `encrypt`(`plaintext`: kotlin.ByteArray): OlmMessage {
            return FfiConverterTypeOlmMessage.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_session_encrypt(
        it, FfiConverterByteArray.lower(`plaintext`),_status)
}
    }
    )
    }
    

    
    /**
     * Have we ever received and decrypted a message from the other side?
     */override fun `hasReceivedMessage`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_session_has_received_message(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Convert the session into a struct which implements serde::Serialize and serde::Deserialize.
     */override fun `pickle`(): SessionPickle {
            return FfiConverterTypeSessionPickle.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_session_pickle(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the SessionConfig that this Session is configured to use.
     */override fun `sessionConfig`(): SessionConfig {
            return FfiConverterTypeSessionConfig.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_session_session_config(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns the globally unique session ID, in base64-encoded form.
     */override fun `sessionId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_session_session_id(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Get the keys associated with this session.
     */override fun `sessionKeys`(): SessionKeys {
            return FfiConverterTypeSessionKeys.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_session_session_keys(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create a Session object by unpickling a session pickle in libolm legacy pickle format.
     */
    @Throws(VodozemacException::class) fun `fromLibolmPickle`(`pickle`: kotlin.String, `pickleKey`: kotlin.ByteArray): Session {
            return FfiConverterTypeSession.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_session_from_libolm_pickle(
        FfiConverterString.lower(`pickle`),FfiConverterByteArray.lower(`pickleKey`),_status)
}
    )
    }
    

        
    /**
     * Restore a Session from a previously saved SessionPickle.
     */
    @Throws(VodozemacException::class) fun `fromPickle`(`pickle`: SessionPickle): Session {
            return FfiConverterTypeSession.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_session_from_pickle(
        FfiConverterTypeSessionPickle.lower(`pickle`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeSession: FfiConverter<Session, Long> {
    override fun lower(value: Session): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): Session {
        return Session(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): Session {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: Session) = 8UL

    override fun write(value: Session, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * Session configuration for Olm sessions.
 */
public interface SessionConfigInterface {
    
    companion object
}

/**
 * Session configuration for Olm sessions.
 */
open class SessionConfig: Disposable, AutoCloseable, SessionConfigInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_sessionconfig(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_sessionconfig(handle, status)
        }
    }

    

    
    companion object {
        
    /**
     * Create a default SessionConfig.
     */ fun `default`(): SessionConfig {
            return FfiConverterTypeSessionConfig.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_sessionconfig_default(
        _status)
}
    )
    }
    

        
    /**
     * Create a SessionConfig for Olm version 1.
     */ fun `version1`(): SessionConfig {
            return FfiConverterTypeSessionConfig.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_sessionconfig_version_1(
        _status)
}
    )
    }
    

        
    /**
     * Create a SessionConfig for Olm version 2.
     */ fun `version2`(): SessionConfig {
            return FfiConverterTypeSessionConfig.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_sessionconfig_version_2(
        _status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeSessionConfig: FfiConverter<SessionConfig, Long> {
    override fun lower(value: SessionConfig): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): SessionConfig {
        return SessionConfig(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): SessionConfig {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: SessionConfig) = 8UL

    override fun write(value: SessionConfig, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * A session key that can be used to create an InboundGroupSession
 *
 * Contains the signed session key for authentication
 */
public interface SessionKeyInterface {
    
    /**
     * Convert the session key to a base64 string
     */
    fun `toBase64`(): kotlin.String
    
    /**
     * Convert the session key to bytes
     */
    fun `toBytes`(): kotlin.ByteArray
    
    companion object
}

/**
 * A session key that can be used to create an InboundGroupSession
 *
 * Contains the signed session key for authentication
 */
open class SessionKey: Disposable, AutoCloseable, SessionKeyInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_sessionkey(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_sessionkey(handle, status)
        }
    }

    
    /**
     * Convert the session key to a base64 string
     */override fun `toBase64`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sessionkey_to_base64(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Convert the session key to bytes
     */override fun `toBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sessionkey_to_bytes(
        it, _status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Create a SessionKey from a base64 string
     */
    @Throws(VodozemacException::class) fun `fromBase64`(`input`: kotlin.String): SessionKey {
            return FfiConverterTypeSessionKey.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_sessionkey_from_base64(
        FfiConverterString.lower(`input`),_status)
}
    )
    }
    

        
    /**
     * Create a SessionKey from bytes
     */
    @Throws(VodozemacException::class) fun `fromBytes`(`bytes`: kotlin.ByteArray): SessionKey {
            return FfiConverterTypeSessionKey.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_sessionkey_from_bytes(
        FfiConverterByteArray.lower(`bytes`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeSessionKey: FfiConverter<SessionKey, Long> {
    override fun lower(value: SessionKey): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): SessionKey {
        return SessionKey(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): SessionKey {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: SessionKey) = 8UL

    override fun write(value: SessionKey, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * Session keys for an Olm session.
 */
public interface SessionKeysInterface {
    
    /**
     * The base key, a single-use Curve25519 key.
     */
    fun `baseKey`(): Curve25519PublicKey
    
    /**
     * The identity key, a long-lived Ed25519 key.
     */
    fun `identityKey`(): Curve25519PublicKey
    
    /**
     * The one time key, a single-use Curve25519 key.
     */
    fun `oneTimeKey`(): Curve25519PublicKey
    
    /**
     * Returns the globally unique session ID, in base64-encoded form.
     */
    fun `sessionId`(): kotlin.String
    
    companion object
}

/**
 * Session keys for an Olm session.
 */
open class SessionKeys: Disposable, AutoCloseable, SessionKeysInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_sessionkeys(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_sessionkeys(handle, status)
        }
    }

    
    /**
     * The base key, a single-use Curve25519 key.
     */override fun `baseKey`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sessionkeys_base_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The identity key, a long-lived Ed25519 key.
     */override fun `identityKey`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sessionkeys_identity_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * The one time key, a single-use Curve25519 key.
     */override fun `oneTimeKey`(): Curve25519PublicKey {
            return FfiConverterTypeCurve25519PublicKey.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sessionkeys_one_time_key(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Returns the globally unique session ID, in base64-encoded form.
     */override fun `sessionId`(): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sessionkeys_session_id(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeSessionKeys: FfiConverter<SessionKeys, Long> {
    override fun lower(value: SessionKeys): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): SessionKeys {
        return SessionKeys(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): SessionKeys {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: SessionKeys) = 8UL

    override fun write(value: SessionKeys, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * A struct representing the pickled Session.
 */
public interface SessionPickleInterface {
    
    /**
     * Serialize and encrypt the pickle using the given key.
     */
    fun `encrypt`(`pickleKey`: kotlin.ByteArray): kotlin.String
    
    companion object
}

/**
 * A struct representing the pickled Session.
 */
open class SessionPickle: Disposable, AutoCloseable, SessionPickleInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_sessionpickle(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_sessionpickle(handle, status)
        }
    }

    
    /**
     * Serialize and encrypt the pickle using the given key.
     */
    @Throws(VodozemacException::class)override fun `encrypt`(`pickleKey`: kotlin.ByteArray): kotlin.String {
            return FfiConverterString.lift(
    callWithHandle {
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sessionpickle_encrypt(
        it, FfiConverterByteArray.lower(`pickleKey`),_status)
}
    }
    )
    }
    

    

    
    companion object {
        
    /**
     * Obtain a pickle from a ciphertext by decrypting and deserializing using the given key.
     */
    @Throws(VodozemacException::class) fun `fromEncrypted`(`ciphertext`: kotlin.String, `pickleKey`: kotlin.ByteArray): SessionPickle {
            return FfiConverterTypeSessionPickle.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_constructor_sessionpickle_from_encrypted(
        FfiConverterString.lower(`ciphertext`),FfiConverterByteArray.lower(`pickleKey`),_status)
}
    )
    }
    

        
    }
    
}


/**
 * @suppress
 */
public object FfiConverterTypeSessionPickle: FfiConverter<SessionPickle, Long> {
    override fun lower(value: SessionPickle): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): SessionPickle {
        return SessionPickle(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): SessionPickle {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: SessionPickle) = 8UL

    override fun write(value: SessionPickle, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}


// This template implements a class for working with a Rust struct via a handle
// to the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque handle to the underlying Rust struct.
//     Method calls need to read this handle from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its handle should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the handle, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the handle, but is interrupted
//      before it can pass the handle over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read handle value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//


//
/**
 * Wrapper around vodozemac::SharedSecret
 *
 * The result of a Diffie-Hellman key exchange
 */
public interface SharedSecretInterface {
    
    /**
     * View this shared secret as a byte array
     *
     * Pattern: Method returning Vec<u8>
     */
    fun `asBytes`(): kotlin.ByteArray
    
    /**
     * Convert the shared secret to bytes
     *
     * Pattern: Method returning Vec<u8>
     */
    fun `toBytes`(): kotlin.ByteArray
    
    /**
     * Check if the key exchange was contributory
     *
     * Returns true if the key exchange was contributory (good),
     * false otherwise (can be bad for some protocols)
     *
     * Pattern: Method returning primitive type (bool)
     */
    fun `wasContributory`(): kotlin.Boolean
    
    companion object
}

/**
 * Wrapper around vodozemac::SharedSecret
 *
 * The result of a Diffie-Hellman key exchange
 */
open class SharedSecret: Disposable, AutoCloseable, SharedSecretInterface
{

    @Suppress("UNUSED_PARAMETER")
    constructor(withHandle: UniffiWithHandle, handle: Long) {
        this.handle = handle
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noHandle: NoHandle) {
        this.handle = 0
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(handle))
    }

    protected val handle: Long
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithHandle(block: (handle: Long) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the handle being freed concurrently.
        try {
            return block(this.uniffiCloneHandle())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(private val handle: Long) : Runnable {
        override fun run() {
            if (handle == 0.toLong()) {
                // Fake object created with `NoHandle`, don't try to free.
                return;
            }
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_free_sharedsecret(handle, status)
            }
        }
    }

    fun uniffiCloneHandle(): Long {
        if (handle == 0.toLong()) {
            throw InternalException("uniffiCloneHandle() called on NoHandle object");
        }
        return uniffiRustCall() { status ->
            UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_clone_sharedsecret(handle, status)
        }
    }

    
    /**
     * View this shared secret as a byte array
     *
     * Pattern: Method returning Vec<u8>
     */override fun `asBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sharedsecret_as_bytes(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Convert the shared secret to bytes
     *
     * Pattern: Method returning Vec<u8>
     */override fun `toBytes`(): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sharedsecret_to_bytes(
        it, _status)
}
    }
    )
    }
    

    
    /**
     * Check if the key exchange was contributory
     *
     * Returns true if the key exchange was contributory (good),
     * false otherwise (can be bad for some protocols)
     *
     * Pattern: Method returning primitive type (bool)
     */override fun `wasContributory`(): kotlin.Boolean {
            return FfiConverterBoolean.lift(
    callWithHandle {
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_method_sharedsecret_was_contributory(
        it, _status)
}
    }
    )
    }
    

    

    
    
    companion object
    
}


/**
 * @suppress
 */
public object FfiConverterTypeSharedSecret: FfiConverter<SharedSecret, Long> {
    override fun lower(value: SharedSecret): Long {
        return value.uniffiCloneHandle()
    }

    override fun lift(value: Long): SharedSecret {
        return SharedSecret(UniffiWithHandle, value)
    }

    override fun read(buf: ByteBuffer): SharedSecret {
        return lift(buf.getLong())
    }

    override fun allocationSize(value: SharedSecret) = 8UL

    override fun write(value: SharedSecret, buf: ByteBuffer) {
        buf.putLong(lower(value))
    }
}



/**
 * Result from dehydrated device creation.
 */
data class DehydratedDeviceResult (
    var `ciphertext`: kotlin.String
    , 
    var `nonce`: kotlin.String
    
) {
    
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeDehydratedDeviceResult: FfiConverterRustBuffer<DehydratedDeviceResult> {
    override fun read(buf: ByteBuffer): DehydratedDeviceResult {
        return DehydratedDeviceResult(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: DehydratedDeviceResult) = (
            FfiConverterString.allocationSize(value.`ciphertext`) +
            FfiConverterString.allocationSize(value.`nonce`)
    )

    override fun write(value: DehydratedDeviceResult, buf: ByteBuffer) {
            FfiConverterString.write(value.`ciphertext`, buf)
            FfiConverterString.write(value.`nonce`, buf)
    }
}




enum class MessageType {
    
    NORMAL,
    PRE_KEY;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeMessageType: FfiConverterRustBuffer<MessageType> {
    override fun read(buf: ByteBuffer) = try {
        MessageType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: MessageType) = 4UL

    override fun write(value: MessageType, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}






enum class SessionOrdering {
    
    EQUAL,
    BETTER,
    WORSE,
    UNCONNECTED;
    companion object
}


/**
 * @suppress
 */
public object FfiConverterTypeSessionOrdering: FfiConverterRustBuffer<SessionOrdering> {
    override fun read(buf: ByteBuffer) = try {
        SessionOrdering.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: SessionOrdering) = 4UL

    override fun write(value: SessionOrdering, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class VodozemacException: kotlin.Exception() {
    
    class Base64Decode(
        
        val v1: kotlin.String
        ) : VodozemacException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class ProtoBufDecode(
        
        val v1: kotlin.String
        ) : VodozemacException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Decode(
        
        val v1: kotlin.String
        ) : VodozemacException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class DehydratedDevice(
        
        val v1: kotlin.String
        ) : VodozemacException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Key(
        
        val v1: kotlin.String
        ) : VodozemacException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class LibolmPickle(
        
        val v1: kotlin.String
        ) : VodozemacException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Pickle(
        
        val v1: kotlin.String
        ) : VodozemacException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Signature(
        
        val v1: kotlin.String
        ) : VodozemacException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Ecies(
        
        val v1: kotlin.String
        ) : VodozemacException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class MegolmDecryption(
        
        val v1: kotlin.String
        ) : VodozemacException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class OlmDecryption(
        
        val v1: kotlin.String
        ) : VodozemacException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class SessionCreation(
        
        val v1: kotlin.String
        ) : VodozemacException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class SessionKeyDecode(
        
        val v1: kotlin.String
        ) : VodozemacException() {
        override val message
            get() = "v1=${ v1 }"
    }
    
    class Sas(
        
        val v1: kotlin.String
        ) : VodozemacException() {
        override val message
            get() = "v1=${ v1 }"
    }
    

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<VodozemacException> {
        override fun lift(error_buf: RustBuffer.ByValue): VodozemacException = FfiConverterTypeVodozemacError.lift(error_buf)
    }

    
}

/**
 * @suppress
 */
public object FfiConverterTypeVodozemacError : FfiConverterRustBuffer<VodozemacException> {
    override fun read(buf: ByteBuffer): VodozemacException {
        

        return when(buf.getInt()) {
            1 -> VodozemacException.Base64Decode(
                FfiConverterString.read(buf),
                )
            2 -> VodozemacException.ProtoBufDecode(
                FfiConverterString.read(buf),
                )
            3 -> VodozemacException.Decode(
                FfiConverterString.read(buf),
                )
            4 -> VodozemacException.DehydratedDevice(
                FfiConverterString.read(buf),
                )
            5 -> VodozemacException.Key(
                FfiConverterString.read(buf),
                )
            6 -> VodozemacException.LibolmPickle(
                FfiConverterString.read(buf),
                )
            7 -> VodozemacException.Pickle(
                FfiConverterString.read(buf),
                )
            8 -> VodozemacException.Signature(
                FfiConverterString.read(buf),
                )
            9 -> VodozemacException.Ecies(
                FfiConverterString.read(buf),
                )
            10 -> VodozemacException.MegolmDecryption(
                FfiConverterString.read(buf),
                )
            11 -> VodozemacException.OlmDecryption(
                FfiConverterString.read(buf),
                )
            12 -> VodozemacException.SessionCreation(
                FfiConverterString.read(buf),
                )
            13 -> VodozemacException.SessionKeyDecode(
                FfiConverterString.read(buf),
                )
            14 -> VodozemacException.Sas(
                FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: VodozemacException): ULong {
        return when(value) {
            is VodozemacException.Base64Decode -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is VodozemacException.ProtoBufDecode -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is VodozemacException.Decode -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is VodozemacException.DehydratedDevice -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is VodozemacException.Key -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is VodozemacException.LibolmPickle -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is VodozemacException.Pickle -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is VodozemacException.Signature -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is VodozemacException.Ecies -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is VodozemacException.MegolmDecryption -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is VodozemacException.OlmDecryption -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is VodozemacException.SessionCreation -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is VodozemacException.SessionKeyDecode -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
            is VodozemacException.Sas -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
                + FfiConverterString.allocationSize(value.v1)
            )
        }
    }

    override fun write(value: VodozemacException, buf: ByteBuffer) {
        when(value) {
            is VodozemacException.Base64Decode -> {
                buf.putInt(1)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is VodozemacException.ProtoBufDecode -> {
                buf.putInt(2)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is VodozemacException.Decode -> {
                buf.putInt(3)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is VodozemacException.DehydratedDevice -> {
                buf.putInt(4)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is VodozemacException.Key -> {
                buf.putInt(5)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is VodozemacException.LibolmPickle -> {
                buf.putInt(6)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is VodozemacException.Pickle -> {
                buf.putInt(7)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is VodozemacException.Signature -> {
                buf.putInt(8)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is VodozemacException.Ecies -> {
                buf.putInt(9)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is VodozemacException.MegolmDecryption -> {
                buf.putInt(10)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is VodozemacException.OlmDecryption -> {
                buf.putInt(11)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is VodozemacException.SessionCreation -> {
                buf.putInt(12)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is VodozemacException.SessionKeyDecode -> {
                buf.putInt(13)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
            is VodozemacException.Sas -> {
                buf.putInt(14)
                FfiConverterString.write(value.v1, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeCurve25519PublicKey: FfiConverterRustBuffer<Curve25519PublicKey?> {
    override fun read(buf: ByteBuffer): Curve25519PublicKey? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeCurve25519PublicKey.read(buf)
    }

    override fun allocationSize(value: Curve25519PublicKey?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeCurve25519PublicKey.allocationSize(value)
        }
    }

    override fun write(value: Curve25519PublicKey?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeCurve25519PublicKey.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterOptionalTypeExportedSessionKey: FfiConverterRustBuffer<ExportedSessionKey?> {
    override fun read(buf: ByteBuffer): ExportedSessionKey? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeExportedSessionKey.read(buf)
    }

    override fun allocationSize(value: ExportedSessionKey?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeExportedSessionKey.allocationSize(value)
        }
    }

    override fun write(value: ExportedSessionKey?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeExportedSessionKey.write(value, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceUShort: FfiConverterRustBuffer<List<kotlin.UShort>> {
    override fun read(buf: ByteBuffer): List<kotlin.UShort> {
        val len = buf.getInt()
        return List<kotlin.UShort>(len) {
            FfiConverterUShort.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.UShort>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterUShort.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<kotlin.UShort>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterUShort.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeCurve25519PublicKey: FfiConverterRustBuffer<List<Curve25519PublicKey>> {
    override fun read(buf: ByteBuffer): List<Curve25519PublicKey> {
        val len = buf.getInt()
        return List<Curve25519PublicKey>(len) {
            FfiConverterTypeCurve25519PublicKey.read(buf)
        }
    }

    override fun allocationSize(value: List<Curve25519PublicKey>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeCurve25519PublicKey.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<Curve25519PublicKey>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeCurve25519PublicKey.write(it, buf)
        }
    }
}




/**
 * @suppress
 */
public object FfiConverterSequenceTypeOneTimeKeyPair: FfiConverterRustBuffer<List<OneTimeKeyPair>> {
    override fun read(buf: ByteBuffer): List<OneTimeKeyPair> {
        val len = buf.getInt()
        return List<OneTimeKeyPair>(len) {
            FfiConverterTypeOneTimeKeyPair.read(buf)
        }
    }

    override fun allocationSize(value: List<OneTimeKeyPair>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeOneTimeKeyPair.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<OneTimeKeyPair>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeOneTimeKeyPair.write(it, buf)
        }
    }
}
        /**
         * Decode a base64 string into bytes with proper error handling
         */
    @Throws(VodozemacException::class) fun `base64Decode`(`input`: kotlin.String): kotlin.ByteArray {
            return FfiConverterByteArray.lift(
    uniffiRustCallWithError(VodozemacException) { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_func_base64_decode(
        FfiConverterString.lower(`input`),_status)
}
    )
    }
    

        /**
         * Encode bytes as a base64 string
         */ fun `base64Encode`(`input`: kotlin.ByteArray): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_func_base64_encode(
        FfiConverterByteArray.lower(`input`),_status)
}
    )
    }
    

        /**
         * Get the version of vodozemac that is being used
         */ fun `getVersion`(): kotlin.String {
            return FfiConverterString.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_vodozemac_bindings_fn_func_get_version(
        _status)
}
    )
    }
    


