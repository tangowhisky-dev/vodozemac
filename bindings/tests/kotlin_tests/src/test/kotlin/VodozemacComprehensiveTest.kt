package org.matrix.vodozemac.test

import kotlinx.serialization.Serializable
import kotlinx.serialization.SerialName
import kotlinx.serialization.json.Json
import org.junit.Test
import org.junit.Assert.*
import org.junit.Before
import java.io.File
import uniffi.vodozemac.*

/**
 * Comprehensive test vector validation suite for Vodozemac Kotlin bindings.
 * This test validates all cryptographic operations against canonical test vectors
 * generated by the Rust reference implementation.
 */

@Serializable
data class TestVectors(
    @SerialName("account_tests") val accountTests: List<AccountTest>,
    @SerialName("session_tests") val sessionTests: List<SessionTest>,
    @SerialName("group_session_tests") val groupSessionTests: List<GroupSessionTest>,
    @SerialName("sas_tests") val sasTests: List<SasTest>,
    @SerialName("ecies_tests") val eciesTests: List<EciesTest>,
    @SerialName("utility_tests") val utilityTests: UtilityTests
)

@Serializable
data class AccountTest(
    val name: String,
    @SerialName("identity_keys") val identityKeys: IdentityKeysData,
    @SerialName("one_time_keys_count") val oneTimeKeysCount: UInt,
    @SerialName("one_time_keys") val oneTimeKeys: Map<String, String>,
    @SerialName("fallback_key") val fallbackKey: Map<String, String>,
    @SerialName("signature_message") val signatureMessage: String,
    val signature: String
)

@Serializable
data class IdentityKeysData(
    val curve25519: String,
    val ed25519: String
)

@Serializable
data class SessionTest(
    val name: String,
    @SerialName("session_id") val sessionId: String,
    val plaintext: String,
    @SerialName("encrypted_message") val encryptedMessage: String,
    @SerialName("decrypted_message") val decryptedMessage: String
)

@Serializable
data class GroupSessionTest(
    val name: String,
    @SerialName("session_id") val sessionId: String,
    @SerialName("session_key") val sessionKey: String,
    @SerialName("message_index") val messageIndex: UInt,
    val plaintext: String,
    @SerialName("encrypted_message") val encryptedMessage: String,
    @SerialName("decrypted_message") val decryptedMessage: String,
    @SerialName("decrypted_index") val decryptedIndex: UInt
)

@Serializable
data class SasTest(
    val name: String,
    @SerialName("alice_public_key") val alicePublicKey: String,
    @SerialName("bob_public_key") val bobPublicKey: String,
    @SerialName("emoji_indices") val emojiIndices: List<UInt>,
    val decimals: List<UInt>
)

@Serializable
data class EciesTest(
    val name: String,
    @SerialName("alice_public_key") val alicePublicKey: String,
    @SerialName("bob_public_key") val bobPublicKey: String,
    val plaintext: String,
    @SerialName("encrypted_message") val encryptedMessage: String,
    @SerialName("decrypted_message") val decryptedMessage: String,
    @SerialName("check_code") val checkCode: UInt
)

@Serializable
data class UtilityTests(
    @SerialName("base64_encode_tests") val base64EncodeTests: List<Base64Test>,
    @SerialName("base64_decode_tests") val base64DecodeTests: List<Base64Test>,
    val version: String
)

@Serializable
data class Base64Test(
    val input: String,
    val output: String
)

class VodozemacComprehensiveTest {
    
    private lateinit var testVectors: TestVectors
    
    @Before
    fun setUp() {
        val testVectorsJson = this::class.java.classLoader.getResource("test_vectors.json")
            ?.readText() ?: throw IllegalStateException("Could not find test_vectors.json")
        
        testVectors = Json.decodeFromString(testVectorsJson)
    }
    
    @Test
    fun testAccountOperations() {
        println("🔑 Testing Account operations...")
        
        testVectors.accountTests.forEach { accountTest ->
            println("  Testing: ${accountTest.name}")
            
            // Create a new account (since we don't have pickle data in the new format)
            val account = Account()
            val identityKeys = account.`identityKeys`()
            
            // Verify identity keys structure
            assertNotNull("Curve25519 key should not be null", identityKeys.`curve25519`())
            assertNotNull("Ed25519 key should not be null", identityKeys.`ed25519`())
            
            // Test signing
            val signature = account.`sign`(accountTest.signatureMessage.toByteArray())
            assertNotNull("Signature should not be null", signature)
            
            // Test one-time key generation
            account.`generateOneTimeKeys`(5u)
            val oneTimeKeys = account.`oneTimeKeys`()
            assertTrue("Should have generated one-time keys", oneTimeKeys.isNotEmpty())
            
            // Test fallback key
            account.`generateFallbackKey`()
            assertTrue("Should have fallback key", !account.`forgetFallbackKey`()) // Should return false as no old key to forget
            
            println("    ✅ Account operations validated")
        }
    }
    
    @Test
    fun testSessionOperations() {
        println("📡 Testing Session operations...")
        
        testVectors.sessionTests.forEach { sessionTest ->
            println("  Testing: ${sessionTest.name}")
            
            // Create Alice and Bob accounts
            val alice = Account()
            val bob = Account()
            
            // Bob generates one-time keys
            bob.`generateOneTimeKeys`(1u)
            val bobOneTimeKeys = bob.`oneTimeKeys`()
            val bobOneTimeKey = bobOneTimeKeys.first().key()
            
            // Alice creates outbound session
            val aliceSession = alice.`createOutboundSession`(
                SessionConfig.`version2`(),
                bob.`identityKeys`().`curve25519`(),
                bobOneTimeKey
            )
            
            // Alice encrypts a message
            val encrypted = aliceSession.`encrypt`(sessionTest.plaintext.toByteArray())
            
            // Cast to PreKeyMessage for the first message
            val bobSessionResult = bob.`createInboundSession`(
                alice.`identityKeys`().`curve25519`(),
                encrypted as PreKeyMessage
            )
            
            assertEquals("Decrypted message should match original", 
                sessionTest.plaintext, String(bobSessionResult.`plaintext`()))
            
            println("    ✅ Session operations validated")
        }
    }
    
    @Test
    fun testGroupSessionOperations() {
        println("👥 Testing Group Session operations...")
        
        testVectors.groupSessionTests.forEach { groupTest ->
            println("  Testing: ${groupTest.name}")
            
            // Create outbound group session
            val outboundSession = GroupSession()
            val sessionKey = outboundSession.`sessionKey`()
            
            // Create inbound session from the key
            val inboundSession = InboundGroupSession(sessionKey, MegolmSessionConfig.`version2`())
            
            // Test session properties
            assertEquals("Session IDs should match", 
                outboundSession.`sessionId`(), inboundSession.`sessionId`())
            
            // Test encryption/decryption
            val encrypted = outboundSession.`encrypt`(groupTest.plaintext.toByteArray())
            val decrypted = inboundSession.`decrypt`(encrypted)
            
            assertEquals("Decrypted message should match original", 
                groupTest.plaintext, String(decrypted.`plaintext`()))
            assertEquals("Message index should be correct", 
                0u, decrypted.`messageIndex`())
            
            println("    ✅ Group session operations validated")
        }
    }
    
    @Test
    fun testSasOperations() {
        println("🔐 Testing SAS operations...")
        
        testVectors.sasTests.forEach { sasTest ->
            println("  Testing: ${sasTest.name}")
            
            // Create SAS objects for Alice and Bob
            val alice = Sas()
            val bob = Sas()
            
            // Get public keys
            val alicePublicKey = alice.`publicKey`()
            val bobPublicKey = bob.`publicKey`()
            
            // Establish shared secrets
            val aliceEstablished = alice.`diffieHellman`(bobPublicKey)
            val bobEstablished = bob.`diffieHellman`(alicePublicKey)
            
            // Generate bytes
            val aliceBytes = aliceEstablished.`bytes`("")
            val bobBytes = bobEstablished.`bytes`("")
            
            // Verify both sides generate the same bytes
            assertEquals("SAS bytes should match", aliceBytes.`emojiIndices`(), bobBytes.`emojiIndices`())
            
            // Test emoji generation
            val aliceEmojis = aliceBytes.`emojiIndices`()
            val bobEmojis = bobBytes.`emojiIndices`()
            
            assertEquals("Emoji indices should match", aliceEmojis, bobEmojis)
            
            // Test decimal generation
            val aliceDecimals = aliceBytes.`decimals`()
            val bobDecimals = bobBytes.`decimals`()
            
            assertEquals("Decimals should match", aliceDecimals, bobDecimals)
            
            println("    ✅ SAS operations validated")
        }
    }
    
    @Test
    fun testEciesOperations() {
        println("🔒 Testing ECIES operations...")
        
        testVectors.eciesTests.forEach { eciesTest ->
            println("  Testing: ${eciesTest.name}")
            
            // Create ECIES instances
            val alice = Ecies()
            val bob = Ecies()
            
            // Get public keys
            val alicePublicKey = alice.`publicKey`()
            val bobPublicKey = bob.`publicKey`()
            
            // Alice establishes outbound channel to Bob
            val aliceResult = alice.`establishOutboundChannel`(bobPublicKey, eciesTest.plaintext.toByteArray())
            
            // Bob establishes inbound channel from Alice's message
            val bobResult = bob.`establishInboundChannel`(aliceResult.`message`())
            
            // Verify decryption
            val decryptedText = String(bobResult.`message`())
            assertEquals("Decrypted message should match original", 
                eciesTest.plaintext, decryptedText)
            
            // Test check codes
            val aliceCheckCode = aliceResult.`ecies`().`checkCode`()
            val bobCheckCode = bobResult.`ecies`().`checkCode`()
            
            assertEquals("Check codes should match", aliceCheckCode.`asBytes`(), bobCheckCode.`asBytes`())
            
            println("    ✅ ECIES operations validated")
        }
    }
    
    @Test
    fun testUtilityFunctions() {
        println("🔧 Testing Utility functions...")
        
        val utilityTests = testVectors.utilityTests
        
        // Test version
        assertEquals("Version should match", `getVersion`(), utilityTests.version)
        
        // Test base64 encoding
        utilityTests.base64EncodeTests.forEach { test ->
            val encoded = `base64Encode`(test.input.toByteArray())
            assertEquals("Base64 encoding should match test vector", encoded, test.output)
        }
        
        // Test base64 decoding
        utilityTests.base64DecodeTests.forEach { test ->
            val decoded = `base64Decode`(test.input)
            val decodedString = String(decoded)
            assertEquals("Base64 decoding should match test vector", decodedString, test.output)
        }
        
        println("✅ Utility functions validated")
    }
    
    @Test
    fun testErrorHandling() {
        println("⚠️ Testing Error handling...")
        
        // Test invalid base64
        try {
            `base64Decode`("invalid base64!")
            fail("Should have thrown exception for invalid base64")
        } catch (e: Exception) {
            // Expected
            println("  ✅ Invalid base64 properly rejected")
        }
        
        // Test invalid group session key
        try {
            InboundGroupSession(SessionKey.`fromBase64`("invalid_session_key"), MegolmSessionConfig.`version2`())
            fail("Should have thrown exception for invalid session key")
        } catch (e: Exception) {
            // Expected
            println("  ✅ Invalid session key properly rejected")
        }
        
        println("✅ Error handling validated")
    }
}
